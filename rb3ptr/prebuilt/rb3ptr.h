/*
Copyright (c) 2017 Jens Stimpfle

Permission is hereby granted, free of charge, to any person obtaining a
copy of this software and associated documentation files (the
"Software"), to deal in the Software without restriction, including
without limitation the rights to use, copy, modify, merge, publish,
distribute, sublicense, and/or sell copies of the Software, and to
permit persons to whom the Software is furnished to do so, subject to
the following conditions:

The above copyright notice and this permission notice shall be included
in all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

*/


/*
 * WARNING:
 *
 * This file was autogenerated with gen-macros.py from files under templates/
 *
 * Autogenerated from git commit 53228734d4659fed8f991da533d0ee31aa31831c
 */


#ifndef RB3_GEN_HEADER
#define RB3_GEN_HEADER

/*
 * ---------------------------------------------------------------------------
 * Preprocessor definitions
 *
 * This file contains preprocessor definitions used across the project. They
 * are implementation details (not part of the user-facing API).
 * ---------------------------------------------------------------------------
 */

/* don't want no assert.h dependency */
#ifndef RB3_DEBUG
#define RB3_ASSERT(cond)
#else
#include <assert.h>
#define RB3_ASSERT assert
#endif

/* don't want no stddef.h dependency */
#ifdef __cplusplus
#define RB3_NULL 0
#else
#define RB3_NULL ((void *)0)
#endif
#define RB3_offsetof(st, m) ((char *)&(((st *)0)->m)-((char *)0))

/* only used in impl */
#define RB3_DIR_BIT (1<<0)
#define RB3_COLOR_BIT (1<<1)
#define RB3_BLACK (0)
#define RB3_RED (RB3_COLOR_BIT)
#define RB3_CHILD_PTR(head, color) ((rb3_ptr)(head) | color)
#define RB3_PARENT_PTR(head, dir) ((rb3_ptr)(head) | dir)


/* Function attributes used for extern linkage */
#define RB3_EXTERN_ATTRS  \
        extern,  \
        static inline __attribute__((unused)),  \
        __attribute__((cold)),  \
        inline __attribute__((always_inline)),  \
        __attribute__((noinline))

/* Function attributes used for static linkage */
#define RB3_STATIC_ATTRS  \
        static __attribute__((unused)),  \
        static inline __attribute__((unused)),  \
        __attribute__((cold)),  \
        inline __attribute__((always_inline)),  \
        __attribute__((noinline))


/*
 * This is the stuff the user wants to use
 */

#define RB3_GEN_IMPL_HEADER()  \
    RB3_GEN_IMPL_HEADER_REAL(RB3_EXTERN_ATTRS)

#define RB3_GEN_IMPL_HEADER_STATIC()  \
    RB3_GEN_IMPL_HEADER_REAL(RB3_STATIC_ATTRS)

#define RB3_GEN_IMPL()  \
    RB3_GEN_IMPL_REAL(RB3_EXTERN_ATTRS)

#define RB3_GEN_IMPL_STATIC()  \
    RB3_GEN_IMPL_REAL(RB3_STATIC_ATTRS)


#define RB3_GEN_INLINE_PROTO(BASENAME, NODE_TYPE, GET_HEAD, GET_NODE)  \
    RB3_GEN_INLINE_PROTO_REAL(RB3_EXTERN_ATTRS, struct BASENAME, NODE_TYPE, GET_HEAD, GET_NODE, BASENAME##_inner_tree, BASENAME##_outer_tree, BASENAME##_init, BASENAME##_exit, BASENAME##_isempty, BASENAME##_get_min, BASENAME##_get_max, BASENAME##_get_prev, BASENAME##_get_next, BASENAME##_get_root, BASENAME##_has_child, BASENAME##_get_child, BASENAME##_get_parent, BASENAME##_get_prev_ancestor, BASENAME##_get_next_ancestor, BASENAME##_get_prev_descendant, BASENAME##_get_next_descendant, BASENAME##_insert_below, BASENAME##_delete_head, BASENAME##_get_parent_dir, BASENAME##_get_base, BASENAME##_get_containing_tree)

#define RB3_GEN_INLINE_PROTO_STATIC(BASENAME, NODE_TYPE, GET_HEAD, GET_NODE)  \
    RB3_GEN_INLINE_PROTO_REAL(RB3_STATIC_ATTRS, struct BASENAME, NODE_TYPE, GET_HEAD, GET_NODE, BASENAME##_inner_tree, BASENAME##_outer_tree, BASENAME##_init, BASENAME##_exit, BASENAME##_isempty, BASENAME##_get_min, BASENAME##_get_max, BASENAME##_get_prev, BASENAME##_get_next, BASENAME##_get_root, BASENAME##_has_child, BASENAME##_get_child, BASENAME##_get_parent, BASENAME##_get_prev_ancestor, BASENAME##_get_next_ancestor, BASENAME##_get_prev_descendant, BASENAME##_get_next_descendant, BASENAME##_insert_below, BASENAME##_delete_head, BASENAME##_get_parent_dir, BASENAME##_get_base, BASENAME##_get_containing_tree)

#define RB3_GEN_NODECMP(BASENAME, SUFFIX, NODE_TYPE, GET_HEAD, GET_NODE, COMPARE_NODE)  \
    RB3_GEN_NODECMP_REAL(RB3_EXTERN_ATTRS, struct BASENAME, NODE_TYPE, GET_HEAD, GET_NODE, COMPARE_NODE, BASENAME##_inner_tree, BASENAME##_outer_tree, BASENAME##_init, BASENAME##_exit, BASENAME##_isempty, BASENAME##_get_min, BASENAME##_get_max, BASENAME##_get_prev, BASENAME##_get_next, BASENAME##_get_root, BASENAME##_has_child, BASENAME##_get_child, BASENAME##_get_parent, BASENAME##_get_prev_ancestor, BASENAME##_get_next_ancestor, BASENAME##_get_prev_descendant, BASENAME##_get_next_descendant, BASENAME##_insert_below, BASENAME##_delete_head, BASENAME##_get_parent_dir, BASENAME##_get_base, BASENAME##_get_containing_tree, BASENAME##_nodecmp##SUFFIX, BASENAME##_find_in_subtree##SUFFIX, BASENAME##_find_parent_in_subtree##SUFFIX, BASENAME##_delete_in_subtree##SUFFIX, BASENAME##_insert_in_subtree##SUFFIX, BASENAME##_find##SUFFIX, BASENAME##_delete##SUFFIX, BASENAME##_insert##SUFFIX)

#define RB3_GEN_NODECMP_STATIC(BASENAME, SUFFIX, NODE_TYPE, GET_HEAD, GET_NODE, COMPARE_NODE)  \
    RB3_GEN_NODECMP_REAL(RB3_STATIC_ATTRS, struct BASENAME, NODE_TYPE, GET_HEAD, GET_NODE, COMPARE_NODE, BASENAME##_inner_tree, BASENAME##_outer_tree, BASENAME##_init, BASENAME##_exit, BASENAME##_isempty, BASENAME##_get_min, BASENAME##_get_max, BASENAME##_get_prev, BASENAME##_get_next, BASENAME##_get_root, BASENAME##_has_child, BASENAME##_get_child, BASENAME##_get_parent, BASENAME##_get_prev_ancestor, BASENAME##_get_next_ancestor, BASENAME##_get_prev_descendant, BASENAME##_get_next_descendant, BASENAME##_insert_below, BASENAME##_delete_head, BASENAME##_get_parent_dir, BASENAME##_get_base, BASENAME##_get_containing_tree, BASENAME##_nodecmp##SUFFIX, BASENAME##_find_in_subtree##SUFFIX, BASENAME##_find_parent_in_subtree##SUFFIX, BASENAME##_delete_in_subtree##SUFFIX, BASENAME##_insert_in_subtree##SUFFIX, BASENAME##_find##SUFFIX, BASENAME##_delete##SUFFIX, BASENAME##_insert##SUFFIX)

#define RB3_GEN_NODECMP_PROTO(BASENAME, SUFFIX, NODE_TYPE, GET_HEAD, GET_NODE, COMPARE_NODE)  \
    RB3_GEN_NODECMP_PROTO_REAL(RB3_EXTERN_ATTRS, struct BASENAME, NODE_TYPE, GET_HEAD, GET_NODE, COMPARE_NODE, BASENAME##_inner_tree, BASENAME##_outer_tree, BASENAME##_init, BASENAME##_exit, BASENAME##_isempty, BASENAME##_get_min, BASENAME##_get_max, BASENAME##_get_prev, BASENAME##_get_next, BASENAME##_get_root, BASENAME##_has_child, BASENAME##_get_child, BASENAME##_get_parent, BASENAME##_get_prev_ancestor, BASENAME##_get_next_ancestor, BASENAME##_get_prev_descendant, BASENAME##_get_next_descendant, BASENAME##_insert_below, BASENAME##_delete_head, BASENAME##_get_parent_dir, BASENAME##_get_base, BASENAME##_get_containing_tree, BASENAME##_nodecmp##SUFFIX, BASENAME##_find_in_subtree##SUFFIX, BASENAME##_find_parent_in_subtree##SUFFIX, BASENAME##_delete_in_subtree##SUFFIX, BASENAME##_insert_in_subtree##SUFFIX, BASENAME##_find##SUFFIX, BASENAME##_delete##SUFFIX, BASENAME##_insert##SUFFIX)

#define RB3_GEN_NODECMP_PROTO_STATIC(BASENAME, SUFFIX, NODE_TYPE, GET_HEAD, GET_NODE, COMPARE_NODE)  \
    RB3_GEN_NODECMP_PROTO_REAL(RB3_STATIC_ATTRS, struct BASENAME, NODE_TYPE, GET_HEAD, GET_NODE, COMPARE_NODE, BASENAME##_inner_tree, BASENAME##_outer_tree, BASENAME##_init, BASENAME##_exit, BASENAME##_isempty, BASENAME##_get_min, BASENAME##_get_max, BASENAME##_get_prev, BASENAME##_get_next, BASENAME##_get_root, BASENAME##_has_child, BASENAME##_get_child, BASENAME##_get_parent, BASENAME##_get_prev_ancestor, BASENAME##_get_next_ancestor, BASENAME##_get_prev_descendant, BASENAME##_get_next_descendant, BASENAME##_insert_below, BASENAME##_delete_head, BASENAME##_get_parent_dir, BASENAME##_get_base, BASENAME##_get_containing_tree, BASENAME##_nodecmp##SUFFIX, BASENAME##_find_in_subtree##SUFFIX, BASENAME##_find_parent_in_subtree##SUFFIX, BASENAME##_delete_in_subtree##SUFFIX, BASENAME##_insert_in_subtree##SUFFIX, BASENAME##_find##SUFFIX, BASENAME##_delete##SUFFIX, BASENAME##_insert##SUFFIX)


#define RB3_FOREACH(BASENAME, TREE, NODE) \
    for (NODE = BASENAME##_get_min(TREE); \
        !!NODE; NODE = BASENAME##_get_next(NODE))

#define RB3_FOREACH_SAFE(BASENAME, TREE, NODE, NODE1) \
    for (NODE = BASENAME##_get_min(TREE); \
        (!!NODE ? (NODE1 = BASENAME##_get_next(NODE), !!NODE) : !!NODE); \
        NODE = NODE1)

/* (END stuff) */


/*
 * ===========================================================================
 * SORRY FOR THIS MESS
 *
 * These macros are only for implementation. Not part of the API.
 * ===========================================================================
 */

#define RB3_GEN_INLINE_PROTO_REAL(argstoexpand, OUTER_TREE_TYPE, NODE_TYPE, GET_HEAD, GET_NODE, INNER_TREE, OUTER_TREE, init, exit, isempty, get_min, get_max, get_prev, get_next, get_root, has_child, get_child, get_parent, get_prev_ancestor, get_next_ancestor, get_prev_descendant, get_next_descendant, insert_below, delete_head, get_parent_dir, get_base, get_containing_tree) RB3_GEN_INLINE_PROTO_TOTALLY_REAL(argstoexpand, OUTER_TREE_TYPE, NODE_TYPE, GET_HEAD, GET_NODE, INNER_TREE, OUTER_TREE, init, exit, isempty, get_min, get_max, get_prev, get_next, get_root, has_child, get_child, get_parent, get_prev_ancestor, get_next_ancestor, get_prev_descendant, get_next_descendant, insert_below, delete_head, get_parent_dir, get_base, get_containing_tree)
#define RB3_GEN_NODECMP_PROTO_REAL(argstoexpand, OUTER_TREE_TYPE, NODE_TYPE, GET_HEAD, GET_NODE, COMPARE_NODE, INNER_TREE, OUTER_TREE, init, exit, isempty, get_min, get_max, get_prev, get_next, get_root, has_child, get_child, get_parent, get_prev_ancestor, get_next_ancestor, get_prev_descendant, get_next_descendant, insert_below, delete_head, get_parent_dir, get_base, get_containing_tree, nodecmp, find_in_subtree, find_parent_in_subtree, delete_in_subtree, insert_in_subtree, find, delete, insert) RB3_GEN_NODECMP_PROTO_TOTALLY_REAL(argstoexpand, OUTER_TREE_TYPE, NODE_TYPE, GET_HEAD, GET_NODE, COMPARE_NODE, INNER_TREE, OUTER_TREE, init, exit, isempty, get_min, get_max, get_prev, get_next, get_root, has_child, get_child, get_parent, get_prev_ancestor, get_next_ancestor, get_prev_descendant, get_next_descendant, insert_below, delete_head, get_parent_dir, get_base, get_containing_tree, nodecmp, find_in_subtree, find_parent_in_subtree, delete_in_subtree, insert_in_subtree, find, delete, insert)
#define RB3_GEN_NODECMP_REAL(argstoexpand, OUTER_TREE_TYPE, NODE_TYPE, GET_HEAD, GET_NODE, COMPARE_NODE, INNER_TREE, OUTER_TREE, init, exit, isempty, get_min, get_max, get_prev, get_next, get_root, has_child, get_child, get_parent, get_prev_ancestor, get_next_ancestor, get_prev_descendant, get_next_descendant, insert_below, delete_head, get_parent_dir, get_base, get_containing_tree, nodecmp, find_in_subtree, find_parent_in_subtree, delete_in_subtree, insert_in_subtree, find, delete, insert) RB3_GEN_NODECMP_TOTALLY_REAL(argstoexpand, OUTER_TREE_TYPE, NODE_TYPE, GET_HEAD, GET_NODE, COMPARE_NODE, INNER_TREE, OUTER_TREE, init, exit, isempty, get_min, get_max, get_prev, get_next, get_root, has_child, get_child, get_parent, get_prev_ancestor, get_next_ancestor, get_prev_descendant, get_next_descendant, insert_below, delete_head, get_parent_dir, get_base, get_containing_tree, nodecmp, find_in_subtree, find_parent_in_subtree, delete_in_subtree, insert_in_subtree, find, delete, insert)

#define RB3_GEN_IMPL_HEADER_REAL(argstoexpand)  RB3_GEN_IMPL_HEADER_TOTALLY_REAL(argstoexpand)
#define RB3_GEN_IMPL_REAL(argstoexpand) RB3_GEN_IMPL_TOTALLY_REAL(argstoexpand)


#define RB3_GEN_INLINE_PROTO_TOTALLY_REAL(RB3_API, RB3_API_STATIC_INLINE, RB3_COLD, RB3_INLINE, RB3_NEVERINLINE, OUTER_TREE_TYPE, NODE_TYPE, GET_HEAD, GET_NODE, INNER_TREE, OUTER_TREE, init, exit, isempty, get_min, get_max, get_prev, get_next, get_root, has_child, get_child, get_parent, get_prev_ancestor, get_next_ancestor, get_prev_descendant, get_next_descendant, insert_below, delete_head, get_parent_dir, get_base, get_containing_tree)  \
RB3_API_STATIC_INLINE \
struct rb3_tree *INNER_TREE(OUTER_TREE_TYPE *tree) \
{ \
        return (struct rb3_tree *) tree; \
} \
 \
RB3_API_STATIC_INLINE \
OUTER_TREE_TYPE *OUTER_TREE(struct rb3_tree *tree) \
{ \
        return (OUTER_TREE_TYPE *) tree; \
} \
 \
RB3_API_STATIC_INLINE \
void init(OUTER_TREE_TYPE *tree) \
{ \
        rb3_init(INNER_TREE(tree)); \
} \
 \
RB3_API_STATIC_INLINE \
void exit(OUTER_TREE_TYPE *tree) \
{ \
        rb3_exit(INNER_TREE(tree)); \
} \
 \
RB3_API_STATIC_INLINE \
int isempty(OUTER_TREE_TYPE *tree) \
{ \
        return rb3_isempty(INNER_TREE(tree)); \
} \
 \
RB3_API_STATIC_INLINE \
NODE_TYPE *get_min(OUTER_TREE_TYPE *tree) \
{ \
        return GET_NODE(rb3_get_min(INNER_TREE(tree))); \
} \
 \
RB3_API_STATIC_INLINE \
NODE_TYPE *get_max(OUTER_TREE_TYPE *tree) \
{ \
        return GET_NODE(rb3_get_max(INNER_TREE(tree))); \
} \
 \
RB3_API_STATIC_INLINE \
NODE_TYPE *get_prev(NODE_TYPE *node) \
{ \
        return GET_NODE(rb3_get_prev(GET_HEAD(node))); \
} \
 \
RB3_API_STATIC_INLINE \
NODE_TYPE *get_next(NODE_TYPE *node) \
{ \
        return GET_NODE(rb3_get_next(GET_HEAD(node))); \
} \
 \
RB3_API_STATIC_INLINE \
NODE_TYPE *get_root(OUTER_TREE_TYPE *tree) \
{ \
        return GET_NODE(rb3_get_root(INNER_TREE(tree))); \
} \
 \
/* \
 * -------------------------- \
 * Binary Search Tree stuff \
 * -------------------------- \
 */ \
 \
RB3_API_STATIC_INLINE \
int has_child(NODE_TYPE *node, int dir) \
{ \
        return rb3_has_child(GET_HEAD(node), dir); \
} \
 \
RB3_API_STATIC_INLINE \
NODE_TYPE *get_child(NODE_TYPE *node, int dir) \
{ \
        return GET_NODE(rb3_get_child(GET_HEAD(node), dir)); \
} \
 \
RB3_API_STATIC_INLINE \
NODE_TYPE *get_parent(NODE_TYPE *node) \
{ \
        struct rb3_head *parent; \
 \
        parent = rb3_get_parent(GET_HEAD(node)); \
        if (rb3_is_base(parent)) \
                return (NODE_TYPE *) 0; \
        return GET_NODE(parent); \
} \
 \
RB3_API_STATIC_INLINE \
NODE_TYPE *get_prev_ancestor(NODE_TYPE *node) \
{ \
        return GET_NODE(rb3_get_prev_ancestor(GET_HEAD(node))); \
} \
 \
RB3_API_STATIC_INLINE \
NODE_TYPE *get_next_ancestor(NODE_TYPE *node) \
{ \
        return GET_NODE(rb3_get_next_ancestor(GET_HEAD(node))); \
} \
 \
RB3_API_STATIC_INLINE \
NODE_TYPE *get_prev_descendant(NODE_TYPE *node) \
{ \
        return GET_NODE(rb3_get_prev_descendant(GET_HEAD(node))); \
} \
 \
RB3_API_STATIC_INLINE \
NODE_TYPE *get_next_descendant(NODE_TYPE *node) \
{ \
        return GET_NODE(rb3_get_next_descendant(GET_HEAD(node))); \
} \
 \
/* \
 * Delete a node that is known to be linked in a tree. \
 * \
 * This is deletion with a refined equivalence relation where nodes are only \
 * equal iff their memory addresses are identical. \
 */ \
RB3_API_STATIC_INLINE \
void delete_head(NODE_TYPE *node) \
{ \
        rb3_delete_head(GET_HEAD(node)); \
} \
 \
RB3_API_STATIC_INLINE \
int get_parent_dir(NODE_TYPE *node) \
{ \
        return rb3_get_parent_dir(GET_HEAD(node)); \
} \
 \
RB3_API_STATIC_INLINE \
OUTER_TREE_TYPE *get_containing_tree(NODE_TYPE *node) \
{ \
        return OUTER_TREE(rb3_get_containing_tree(GET_HEAD(node))); \
} \


#define RB3_GEN_NODECMP_PROTO_TOTALLY_REAL(RB3_API, RB3_API_STATIC_INLINE, RB3_COLD, RB3_INLINE, RB3_NEVERINLINE, OUTER_TREE_TYPE, NODE_TYPE, GET_HEAD, GET_NODE, COMPARE_NODE, INNER_TREE, OUTER_TREE, init, exit, isempty, get_min, get_max, get_prev, get_next, get_root, has_child, get_child, get_parent, get_prev_ancestor, get_next_ancestor, get_prev_descendant, get_next_descendant, insert_below, delete_head, get_parent_dir, get_base, get_containing_tree, nodecmp, find_in_subtree, find_parent_in_subtree, delete_in_subtree, insert_in_subtree, find, delete, insert)  \
/** \
 * Find `node` in `tree` using the comparison function handed to the macro \
 * that generates this function. \
 */ \
RB3_API \
NODE_TYPE *find(OUTER_TREE_TYPE *tree, NODE_TYPE *node); \
 \
/** \
 * Delete `node` from `tree` using the comparison function handed to the macro \
 * that generates this function. \
 */ \
RB3_API \
NODE_TYPE *delete(OUTER_TREE_TYPE *tree, NODE_TYPE *node); \
 \
/** \
 * Insert `node` into `tree` using the comparison function handed to the macro \
 * that generates this function. \
 */ \
RB3_API \
NODE_TYPE *insert(OUTER_TREE_TYPE *tree, NODE_TYPE *node); \
 \
 \
/* \
 * --------------------------------------------------------------------------- \
 * Internal stuff (probably not useful) \
 * --------------------------------------------------------------------------- \
 */ \
 \
/** \
 * Find a node in the subtree indicated by `subtree` (inclusively). \
 */ \
RB3_API \
NODE_TYPE *find_in_subtree(NODE_TYPE *subtree, NODE_TYPE *node); \
 \
/** \
 * Find insertion point in subtree. The subtree is indicated by its parent and \
 * the child direction in which the parent links the subtree. \
 * \
 * Parent must be non-NULL, but it could be the base (and the latter is the \
 * reason why it can't be a NODE_TYPE but must be a struct rb3_head). \
 */ \
RB3_API \
NODE_TYPE *find_parent_in_subtree(struct rb3_head *parent, int dir, NODE_TYPE *node, struct rb3_head **parent_out, int *dir_out); \


#define RB3_GEN_NODECMP_TOTALLY_REAL(RB3_API, RB3_API_STATIC_INLINE, RB3_COLD, RB3_INLINE, RB3_NEVERINLINE, OUTER_TREE_TYPE, NODE_TYPE, GET_HEAD, GET_NODE, COMPARE_NODE, INNER_TREE, OUTER_TREE, init, exit, isempty, get_min, get_max, get_prev, get_next, get_root, has_child, get_child, get_parent, get_prev_ancestor, get_next_ancestor, get_prev_descendant, get_next_descendant, insert_below, delete_head, get_parent_dir, get_base, get_containing_tree, nodecmp, find_in_subtree, find_parent_in_subtree, delete_in_subtree, insert_in_subtree, find, delete, insert)  \
/* \
 * --------------------------------------------------------------------------- \
 * Nodecmp \
 * \
 * This file implements the typesafe wrapper for comparison related functions \
 * (find, insert, delete). \
 * --------------------------------------------------------------------------- \
 */ \
 \
RB3_API_STATIC_INLINE \
int nodecmp(struct rb3_head *a, NODE_TYPE *b) \
{ \
        return COMPARE_NODE(GET_NODE(a), b); \
} \
 \
RB3_API RB3_NEVERINLINE \
NODE_TYPE *find_in_subtree(NODE_TYPE *subtree, NODE_TYPE *node) \
{ \
        return GET_NODE(rb3_INLINE_find_in_subtree(GET_HEAD(subtree), (rb3_datacmp) nodecmp, GET_HEAD(node))); \
} \
 \
RB3_API RB3_NEVERINLINE \
NODE_TYPE *find_parent_in_subtree(struct rb3_head *parent, int dir, NODE_TYPE *node, struct rb3_head **parent_out, int *dir_out) \
{ \
        return GET_NODE(rb3_INLINE_find_parent_in_subtree(parent, dir, (rb3_datacmp) nodecmp, node, parent_out, dir_out)); \
} \
 \
RB3_API \
NODE_TYPE *find(OUTER_TREE_TYPE *tree, NODE_TYPE *node) \
{ \
        return find_in_subtree(get_root(tree), node); \
} \
 \
RB3_API \
NODE_TYPE *delete(OUTER_TREE_TYPE *tree, NODE_TYPE *node) \
{ \
        NODE_TYPE *found; \
 \
        found = find_in_subtree(get_root(tree), node); \
        if (found) \
                rb3_delete_head(GET_HEAD(found)); \
        return found; \
} \
 \
RB3_API \
NODE_TYPE *insert(OUTER_TREE_TYPE *tree, NODE_TYPE *node) \
{ \
        NODE_TYPE *found; \
        struct rb3_head *parent; \
        int dir; \
 \
        found = find_parent_in_subtree(&INNER_TREE(tree)->base, RB3_LEFT, node, &parent, &dir); \
        if (!found) \
                rb3_insert_below(GET_HEAD(node), parent, dir); \
        return found; \
} \



#define RB3_GEN_IMPL_TOTALLY_REAL_TYPES(RB3_API, RB3_API_STATIC_INLINE, RB3_COLD, RB3_INLINE, RB3_NEVERINLINE)  \
/* \
 * --------------------------------------------------------------------------- \
 * Types \
 * \
 * This file provides the typedefs and struct definitions that are required \
 * for the type-agnostic API. \
 * --------------------------------------------------------------------------- \
 */ \
 \
/** \
 * This type is used to efficiently store a pointer (at least 4-byte aligned) \
 * and some more information in the unused low bits. \
 */ \
typedef unsigned long rb3_ptr; \
 \
/** \
 * Directions for navigation in the tree. \
 */ \
enum { \
        RB3_LEFT = 0, \
        RB3_RIGHT = 1, \
}; \
 \
/** \
 * Node type for 3-pointer Red-black trees. \
 */ \
struct rb3_head { \
        /* \
         * Left, right, and parent pointers. \
         * \
         * The left and right pointers have additional color bits. \
         * \
         * The parent pointer contains a direction bit indicating the direction \
         * to this child. \
         */ \
        rb3_ptr child[2]; \
        rb3_ptr parent; \
}; \
 \
/** \
 * Tree type. It's just a fake base head that is wrapped for type safety and \
 * future extensibility. \
 */ \
struct rb3_tree { \
        struct rb3_head base; \
}; \
 \
/** \
 * User-provided comparison function. It must first cast (and offset) the \
 * pointers to compare the client-side structures that embed `a` and `b`. \
 * \
 * If a < b, returns some value < 0. \
 * If a > b, returns some value > 0. \
 * If a == b, returns 0. \
 * \
 * This function type is used by the implementation for deciding which child \
 * direction to take to find insertion or deletion points in a tree. \
 * \
 * In some cases, non-strictly monotonic comparison functions (with regards to \
 * the ordering of the nodes in a tree) make sense. An example is \
 * rb3_find_first() which needs only a monotonic "predicate" to return the \
 * first node in the tree that "compares" equal (i.e. where the "predicate" \
 * returns 0). \
 */ \
typedef int (*rb3_cmp)(struct rb3_head *a, struct rb3_head *b); \
 \
/** \
 * User-provided search function. This is a more general variant of rb3_cmp \
 * that supports more specialized searches in a tree. \
 * \
 * If head_in_tree is "smaller" than data, returns some value < 0. \
 * If head_in_tree is "greater" than data, returns some value > 0. \
 * If head_in_tree is "equal" to data, returns 0. \
 * \
 * As stated above this is a generalization of rb3_cmp. Conversely, rb3_cmp is \
 * a specialization of rb3_pred that expects another struct rb3_head pointer \
 * as `data` argument. \
 * \
 * This function type is required for some complex applications where \
 * additional context is needed to make decisions. For example, in Fortune's \
 * algorithm, the order of any two given intersection points is parameterized \
 * by the moving beachlines. (The client code must make sure that nodes are \
 * deleted from the tree before their ordering with respect to other elements \
 * in the tree changes (rendering the tree invalid)). \
 * \
 * Another use case of rb3_datacmp is looking for nodes in a tree without any \
 * reference node at all. An obvious example is searching the first node in a \
 * tree of 2D coordinates that has x-value greater than a given reference \
 * value. \
 */ \
typedef int (*rb3_datacmp)(struct rb3_head *head_in_tree, void *data); \
 \
/** \
 * Get direction from parent to child by testing the direction \
 * \
 * Return RB3_LEFT or RB3_RIGHT, depending on whether this node is the left or \
 * right child of its parent node. If the given node is the root node, \
 * RB3_LEFT is returned. (Technically the root node is the left child of the \
 * base node). \
 * \
 * This is more convenient and (in theory) more efficient than getting the \
 * parent and testing its left and right child. \
 */ \
RB3_API_STATIC_INLINE \
int rb3_get_parent_dir(struct rb3_head *head); \
 \
/** \
 * Get parent head, or NULL if given node is the base node. \
 * \
 * Note that normally you don't want to visit the base node but stop already \
 * at the root node. \
 * \
 * Time complexity: O(1) \
 */ \
RB3_API_STATIC_INLINE \
struct rb3_head *rb3_get_parent(struct rb3_head *head); \
 \
/* \
 * Test if a (left or right) child exists \
 * \
 * This is slightly more efficient than calling rb3_get_child() and comparing \
 * to NULL. \
 * \
 * Time complexity: O(1) \
 */ \
RB3_API_STATIC_INLINE \
int rb3_has_child(struct rb3_head *head, int dir); \
 \
/** \
 * Get child in given direction, or NULL if there is no such child. `dir` \
 * must be RB3_LEFT or RB3_RIGHT. \
 * \
 * Time complexity: O(1) \
 */ \
RB3_API_STATIC_INLINE \
struct rb3_head *rb3_get_child(struct rb3_head *head, int dir); \
 \
/** \
 * Get fake base of tree. \
 * \
 * Warning: the special base element is never embedded in a client payload \
 * structure. It's just a link to host the real root of the tree as its left \
 * child. \
 */ \
RB3_API_STATIC_INLINE \
struct rb3_head *rb3_get_base(struct rb3_tree *tree); \
 \
/* \
 * --------------------------------------------------------------------------- \
 * Inline implementations \
 * --------------------------------------------------------------------------- \
 */ \
 \
RB3_API_STATIC_INLINE \
int rb3_is_base(struct rb3_head *head) \
{ \
	return !head->parent; \
} \
 \
RB3_API_STATIC_INLINE \
int rb3_get_parent_dir(struct rb3_head *head) \
{ \
        return head->parent & 1; \
} \
 \
RB3_API_STATIC_INLINE \
struct rb3_head *rb3_get_parent(struct rb3_head *head) \
{ \
        return (struct rb3_head *)(head->parent & ~3); \
} \
 \
RB3_API_STATIC_INLINE \
int rb3_has_child(struct rb3_head *head, int dir) \
{ \
        return head->child[dir] != 0; \
} \
 \
RB3_API_STATIC_INLINE \
struct rb3_head *rb3_get_child(struct rb3_head *head, int dir) \
{ \
        return (struct rb3_head *)((head->child[dir]) & ~3); \
} \
 \
RB3_API_STATIC_INLINE \
struct rb3_head *rb3_get_base(struct rb3_tree *tree) \
{ \
        return &tree->base; \
} \


#define RB3_GEN_IMPL_TOTALLY_REAL_BASIC(RB3_API, RB3_API_STATIC_INLINE, RB3_COLD, RB3_INLINE, RB3_NEVERINLINE)  \
/* \
 * --------------------------------------------------------------------------- \
 * BASIC API \
 * \
 * These functions provide basic usability as an abstract ordered container. \
 * Often they are all you need to know. \
 * --------------------------------------------------------------------------- \
 */ \
 \
/** \
 * Initialize an rb3_tree. \
 * \
 * Time complexity: O(1) \
 */ \
RB3_API \
void rb3_init(struct rb3_tree *tree); \
 \
/** \
 * Free resources allocated by an rb3_tree (currently none, but this could \
 * change). \
 */ \
RB3_API \
void rb3_exit(struct rb3_tree *tree); \
 \
/** \
 * Check if tree is empty. \
 * \
 * Time complexity: O(1) \
 */ \
RB3_API_STATIC_INLINE \
int rb3_isempty(struct rb3_tree *tree); \
 \
/** \
 * Get minimum (leftmost) element, or NULL if tree is empty. \
 * \
 * Time complexity: O(log n) \
 */ \
RB3_API \
struct rb3_head *rb3_get_min(struct rb3_tree *tree); \
 \
/** \
 * Get maximum (rightmost) element, or NULL if tree is empty \
 * \
 * Time complexity: O(log n) \
 */ \
RB3_API \
struct rb3_head *rb3_get_max(struct rb3_tree *tree); \
 \
/** \
 * Get previous in-order node (maximal node in the tree that sorts before the \
 * given element) or NULL if no such element is in the tree. \
 * \
 * Time complexity: O(log n), amortized over sequential scan: O(1) \
 */ \
RB3_API \
struct rb3_head *rb3_get_prev(struct rb3_head *head); \
 \
/** \
 * Get next in-order node (minimal node in the tree that sorts after the given \
 * element) or NULL if no such element is in the tree. \
 * \
 * Time complexity: O(log n), amortized over sequential scan: O(1) \
 */ \
RB3_API \
struct rb3_head *rb3_get_next(struct rb3_head *head); \
 \
/** \
 * Insert `head` into `tree` using `cmp` to direct the search. At each visited \
 * node in the tree `cmp` is called with that node and `head` as arguments (in \
 * that order). If a node that compares equal is found, it is returned. \
 * Otherwise, `head` is inserted into the tree and NULL is returned. \
 * \
 * Time complexity: O(log n) \
 */ \
RB3_API \
struct rb3_head *rb3_insert(struct rb3_tree *tree, struct rb3_head *head, rb3_cmp cmp); \
 \
/** \
 * Find `head` in `tree` using `cmp` to direct the search. At each visited \
 * node in the tree `cmp` is called with that node and `head` as arguments (in \
 * that order). If a node that compares equal is found, it is returned. \
 * Otherwise, NULL is returned. \
 * \
 * Time complexity: O(log n) \
 */ \
RB3_API \
struct rb3_head *rb3_find(struct rb3_tree *tree, rb3_cmp cmp, struct rb3_head *head); \
 \
/** \
 * Delete `head` from `tree` using `cmp` to direct the search. At each visited \
 * node in the tree `cmp` is called with that node and `head` as arguments (in \
 * that order). If a node that compares equal is found, it is unlinked from \
 * the tree and returned. Otherwise, NULL is returned. \
 * \
 * Time complexity: O(log n) \
 */ \
RB3_API \
struct rb3_head *rb3_delete(struct rb3_tree *tree, rb3_cmp cmp, struct rb3_head *head); \
 \
/** \
 * Like rb3_insert() but use a rb3_datacmp comparison function and `data` to \
 * direct the search. Note in particular that `head` is not used during the \
 * search phase. \
 */ \
RB3_API \
struct rb3_head *rb3_insert_datacmp(struct rb3_tree *tree, struct rb3_head *head, rb3_datacmp datacmp, void *data); \
 \
/** \
 * Like rb3_find() but use a rb3_datacmp comparison function and `data` to \
 * direct the search. \
 */ \
RB3_API \
struct rb3_head *rb3_find_datacmp(struct rb3_tree *tree, rb3_datacmp cmp, void *data); \
 \
/** \
 * Like rb3_delete() but use a rb3_datacmp comparison function and `data` to \
 * direct the search. \
 */ \
RB3_API \
struct rb3_head *rb3_delete_datacmp(struct rb3_tree *tree, rb3_datacmp cmp, void *data); \
 \
/* \
 * Inline implementations \
 */ \
 \
RB3_API_STATIC_INLINE \
int rb3_isempty(struct rb3_tree *tree) \
{ \
        return !rb3_has_child(rb3_get_base(tree), RB3_LEFT); \
} \


#define RB3_GEN_IMPL_TOTALLY_REAL_NAVIGATE(RB3_API, RB3_API_STATIC_INLINE, RB3_COLD, RB3_INLINE, RB3_NEVERINLINE)  \
/* \
 * --------------------------------------------------------------------------- \
 * Navigational API \
 * \
 * These functions provide advanced functionality for navigation in a \
 * binary search tree. \
 * --------------------------------------------------------------------------- \
 */ \
 \
/** \
 * Get topmost element of tree (or NULL if empty) \
 * \
 * Time complexity: O(1) \
 */ \
RB3_API_STATIC_INLINE \
struct rb3_head *rb3_get_root(struct rb3_tree *tree); \
 \
/** \
 * Get previous in-order ancestor (maximal ancestor node that sorts before the \
 * given element) or NULL if no such element is in the tree. \
 * \
 * Time complexity: O(log n) \
 */ \
RB3_API \
struct rb3_head *rb3_get_prev_ancestor(struct rb3_head *head); \
 \
/** \
 * Get next in-order ancestor (minimal ancestor node that sorts after the \
 * given element) or NULL if no such element is in the tree. \
 * \
 * Time complexity: O(log n) \
 */ \
RB3_API \
struct rb3_head *rb3_get_next_ancestor(struct rb3_head *head); \
 \
/** \
 * Get previous in-order descendant (maximal descendant node that sorts before \
 * the given element) or NULL if no such element is in the tree. \
 * \
 * Time complexity: O(log n) \
 */ \
RB3_API \
struct rb3_head *rb3_get_prev_descendant(struct rb3_head *head); \
 \
/** \
 * Get next in-order descendant (minimal descendant node that sorts after the \
 * given element) or NULL if no such element is in the tree. \
 * \
 * Time complexity: O(log n) \
 */ \
RB3_API \
struct rb3_head *rb3_get_next_descendant(struct rb3_head *head); \
 \
/* \
 * Inline implementations \
 */ \
 \
RB3_API_STATIC_INLINE \
struct rb3_head *rb3_get_root(struct rb3_tree *tree) \
{ \
        return rb3_get_child(&tree->base, RB3_LEFT); \
} \


#define RB3_GEN_IMPL_TOTALLY_REAL_INTERNAL(RB3_API, RB3_API_STATIC_INLINE, RB3_COLD, RB3_INLINE, RB3_NEVERINLINE)  \
/* \
 * --------------------------------------------------------------------------- \
 * Internal API \
 * \
 * These functions expose some of the more stable implementation details that \
 * might be useful in other places. They are generally unsafe to use. Make \
 * sure to read the assumptions that must hold before calling them. \
 * --------------------------------------------------------------------------- \
 */ \
 \
/** \
 * Like rb3_find_datacmp() but starts at the given subtree represented by a \
 * link head (which may be NULL) instead of at the root of the tree. \
 */ \
RB3_API \
struct rb3_head *rb3_find_in_subtree_datacmp(struct rb3_head *subtree, rb3_datacmp cmp, void *data); \
 \
/** \
 * Find suitable insertion point for a new node in a subtree, directed by the \
 * rb3_datacmp search. The subtree is given by its parent node `parent` and \
 * child direction `dir`. The insertion point and its child direction are \
 * returned in `parent_out` and `dir_out`. \
 * \
 * If the searched node is already in the tree (the compare function returns \
 * 0), it is returned. In this case `parent_out` and `dir_out` are left \
 * untouched. \
 */ \
RB3_API \
struct rb3_head *rb3_find_parent_in_subtree_datacmp(struct rb3_head *parent, int dir, rb3_datacmp cmp, void *data, struct rb3_head **parent_out, int *dir_out); \
 \
/** \
 * Insert a node below another node in the given direction (RB3_LEFT or \
 * RB3_RIGHT). The new node must replace a leaf. You can use rb3_find_parent() \
 * to find the insertion point. \
 * \
 * Time complexity: O(log n) \
 */ \
RB3_API \
void rb3_insert_below(struct rb3_head *head, struct rb3_head *parent, int dir); \
 \
/** \
 * Delete a node that is known to be linked in a tree. \
 * \
 * This is more efficient than using rb3_find() because no search is needed. \
 * On the downside, the user must guarantee that the node really is linked in \
 * some tree. \
 * \
 * Time complexity: O(log n) \
 */ \
RB3_API \
void rb3_delete_head(struct rb3_head *head); \
 \
/** \
 * Given a node that is known to be linked in _some_ tree, find that tree. \
 */ \
RB3_API \
struct rb3_tree *rb3_get_containing_tree(struct rb3_head *head); \
 \
/* \
 * Inline implementations \
 */ \
 \
 \
/* this interface is meant for code generation, not for casual consumption */ \
RB3_API_STATIC_INLINE \
struct rb3_head *rb3_INLINE_find_in_subtree(struct rb3_head *subtree, rb3_datacmp cmp, void *data) \
{ \
        struct rb3_head *head; \
        int dir; \
        int r; \
 \
        head = subtree; \
        while (head) { \
                r = cmp(head, data); \
                if (r < 0) \
                        dir = RB3_RIGHT; \
                else if (r > 0) \
                        dir = RB3_LEFT; \
                else \
                        return head; \
                head = rb3_get_child(head, dir); \
        } \
        return RB3_NULL; \
} \
 \
/* this interface is meant for code generation, not for casual consumption */ \
RB3_API_STATIC_INLINE \
struct rb3_head *rb3_INLINE_find_parent_in_subtree(struct rb3_head *parent, int dir, rb3_datacmp cmp, void *data, struct rb3_head **parent_out, int *dir_out) \
{ \
        struct rb3_head *head; \
        int r; \
 \
        RB3_ASSERT(parent != RB3_NULL); \
        do { \
                head = rb3_get_child(parent, dir); \
                if (!head) \
                        break; \
                r = cmp(head, data); \
                if (r < 0) \
                        dir = RB3_RIGHT; \
                else if (r > 0) \
                        dir = RB3_LEFT; \
                else \
                        return head; \
                parent = head; \
        } while (head); \
        *parent_out = parent; \
        *dir_out = dir; \
        return RB3_NULL; \
} \


#define RB3_GEN_IMPL_TOTALLY_REAL_IMPL(RB3_API, RB3_API_STATIC_INLINE, RB3_COLD, RB3_INLINE, RB3_NEVERINLINE)  \
/* \
 * --------------------------------------------------------------------------- \
 * Implementation \
 * \
 * This file provides the (key)type-agnostic tree code that can be shared \
 * across all tree instances (with differing key types). \
 * --------------------------------------------------------------------------- \
 */ \
 \
static RB3_INLINE \
struct rb3_head *rb3_get_black_child(struct rb3_head *head, int dir) \
{ \
        return (struct rb3_head *) head->child[dir]; \
} \
 \
static RB3_INLINE \
int rb3_get_color_bit(struct rb3_head *head, int dir) \
{ \
        return head->child[dir] & RB3_COLOR_BIT; \
} \
 \
static RB3_INLINE \
int rb3_is_red(struct rb3_head *head, int dir) \
{ \
        return rb3_get_color_bit(head, dir) != 0; \
} \
 \
static RB3_INLINE \
void rb3_set_red(struct rb3_head *head, int dir) \
{ \
        head->child[dir] |= RB3_COLOR_BIT; \
} \
 \
static RB3_INLINE \
void rb3_set_black(struct rb3_head *head, int dir) \
{ \
        head->child[dir] &= ~RB3_COLOR_BIT; \
} \
 \
static RB3_INLINE \
void rb3_connect(struct rb3_head *head, int dir, struct rb3_head *child, int color) \
{ \
        head->child[dir] = RB3_CHILD_PTR(child, color); \
        child->parent = RB3_PARENT_PTR(head, dir); \
} \
 \
static RB3_INLINE \
void rb3_connect_null(struct rb3_head *head, int dir, struct rb3_head *child, int color) \
{ \
        head->child[dir] = RB3_CHILD_PTR(child, color); \
        if (child) \
                child->parent = RB3_PARENT_PTR(head, dir); \
} \
 \
RB3_API \
struct rb3_tree *rb3_get_containing_tree(struct rb3_head *head) \
{ \
        while (rb3_get_parent(head)) \
                head = rb3_get_parent(head); \
        return (struct rb3_tree *) ((char *) head - (RB3_offsetof(struct rb3_head, child[0]))); \
} \
 \
static RB3_NEVERINLINE \
struct rb3_head *rb3_get_minmax_in_subtree(struct rb3_head *head, int dir) \
{ \
        if (!head) \
                return RB3_NULL; \
        while (rb3_has_child(head, dir)) \
                head = rb3_get_child(head, dir); \
        return head; \
} \
 \
RB3_API \
struct rb3_head *rb3_get_min(struct rb3_tree *tree) \
{ \
        return rb3_get_minmax_in_subtree(rb3_get_root(tree), RB3_LEFT); \
} \
 \
RB3_API \
struct rb3_head *rb3_get_max(struct rb3_tree *tree) \
{ \
        return rb3_get_minmax_in_subtree(rb3_get_root(tree), RB3_RIGHT); \
} \
 \
RB3_API \
struct rb3_head *rb3_get_prev_descendant(struct rb3_head *head) \
{ \
        return rb3_get_minmax_in_subtree(rb3_get_child(head, RB3_LEFT), RB3_RIGHT); \
} \
 \
RB3_API \
struct rb3_head *rb3_get_next_descendant(struct rb3_head *head) \
{ \
        return rb3_get_minmax_in_subtree(rb3_get_child(head, RB3_RIGHT), RB3_LEFT); \
} \
 \
RB3_API \
struct rb3_head *rb3_get_prev_ancestor(struct rb3_head *head) \
{ \
        while (head && rb3_get_parent_dir(head) == RB3_LEFT) \
                head = rb3_get_parent(head); \
        if (head) \
                head = rb3_get_parent(head); \
        return head; \
} \
 \
RB3_API \
struct rb3_head *rb3_get_next_ancestor(struct rb3_head *head) \
{ \
        while (head && rb3_get_parent_dir(head) == RB3_RIGHT) \
                head = rb3_get_parent(head); \
        head = rb3_get_parent(head); \
        if (head && !rb3_get_parent(head)) \
                /* base fake element */ \
                head = RB3_NULL; \
        return head; \
} \
 \
RB3_API \
struct rb3_head *rb3_get_prev(struct rb3_head *head) \
{ \
        if (rb3_has_child(head, RB3_LEFT)) \
                return rb3_get_prev_descendant(head); \
        else \
                return rb3_get_prev_ancestor(head); \
} \
 \
RB3_API \
struct rb3_head *rb3_get_next(struct rb3_head *head) \
{ \
        if (rb3_has_child(head, RB3_RIGHT)) \
                return rb3_get_next_descendant(head); \
        else \
                return rb3_get_next_ancestor(head); \
} \
 \
/* insert implementation */ \
 \
static RB3_NEVERINLINE \
void rb3_insert_rebalance(struct rb3_head *head) \
{ \
        struct rb3_head *pnt; \
        struct rb3_head *gpnt; \
        struct rb3_head *ggpnt; \
        int left; \
        int right; \
        int gdir; \
        int ggdir; \
 \
        if (!rb3_get_parent(rb3_get_parent(head))) { \
                rb3_set_black(rb3_get_parent(head), RB3_LEFT); \
                return; \
        } \
 \
        if (!rb3_is_red(rb3_get_parent(rb3_get_parent(head)), rb3_get_parent_dir(rb3_get_parent(head)))) \
                /* parent is black */ \
                return; \
 \
        /* \
         * Since parent is red parent can't be the root. \
         * So we have at least a grandparent node, and grand-grandparent \
         * is either a real node or the base head. \
         */ \
        pnt = rb3_get_parent(head); \
        gpnt = rb3_get_parent(pnt); \
        ggpnt = rb3_get_parent(gpnt); \
        left = rb3_get_parent_dir(head); \
        right = !rb3_get_parent_dir(head); \
        gdir = rb3_get_parent_dir(pnt); \
        ggdir = rb3_get_parent_dir(gpnt); \
 \
        if (rb3_is_red(gpnt, !gdir)) { \
                /* uncle and parent are both red */ \
                rb3_set_red(ggpnt, ggdir); \
                rb3_set_black(gpnt, RB3_LEFT); \
                rb3_set_black(gpnt, RB3_RIGHT); \
                rb3_insert_rebalance(gpnt); \
        } else if (gdir == right) { \
                rb3_connect_null(pnt, left, rb3_get_black_child(head, right), RB3_BLACK); \
                rb3_connect_null(gpnt, right, rb3_get_black_child(head, left), RB3_BLACK); \
                rb3_connect(head, left, gpnt, RB3_RED); \
                rb3_connect(head, right, pnt, RB3_RED); \
                rb3_connect(ggpnt, ggdir, head, RB3_BLACK); \
        } else { \
                rb3_connect_null(gpnt, left, rb3_get_black_child(pnt, right), RB3_BLACK); \
                rb3_connect(pnt, right, gpnt, RB3_RED); \
                rb3_connect(ggpnt, ggdir, pnt, RB3_BLACK); \
        } \
} \
 \
RB3_API RB3_NEVERINLINE \
void rb3_insert_below(struct rb3_head *head, struct rb3_head *parent, int dir) \
{ \
        RB3_ASSERT(dir == RB3_LEFT || dir == RB3_RIGHT); \
        RB3_ASSERT(!rb3_has_child(parent, dir)); \
 \
        parent->child[dir] = RB3_CHILD_PTR(head, RB3_RED); \
        head->parent = RB3_PARENT_PTR(parent, dir); \
        head->child[RB3_LEFT] = RB3_CHILD_PTR(RB3_NULL, RB3_BLACK); \
        head->child[RB3_RIGHT] = RB3_CHILD_PTR(RB3_NULL, RB3_BLACK); \
        rb3_insert_rebalance(head); \
} \
 \
/* delete implementation */ \
 \
static RB3_NEVERINLINE \
void rb3_delete_rebalance(struct rb3_head *head) \
{ \
        struct rb3_head *pnt; \
        struct rb3_head *gpnt; \
        struct rb3_head *sibling; \
        struct rb3_head *sleft; \
        struct rb3_head *sleftleft; \
        struct rb3_head *sleftright; \
        int left; \
        int right; \
        int gdir; \
 \
        if (!rb3_get_parent(head)) \
                return; \
 \
        if (!rb3_get_parent(rb3_get_parent(head))) \
                return; \
 \
        pnt = rb3_get_parent(head); \
        left = rb3_get_parent_dir(head); \
        right = !rb3_get_parent_dir(head); \
        gpnt = rb3_get_parent(pnt); \
        gdir = rb3_get_parent_dir(pnt); \
        sibling = rb3_get_child(pnt, right); \
        sleft = rb3_get_child(sibling, left); \
 \
        if (rb3_is_red(pnt, right)) { \
                /* sibling is red */ \
                rb3_connect(pnt, right, sleft, RB3_BLACK); \
                rb3_connect(sibling, left, pnt, RB3_RED); \
                rb3_connect(gpnt, gdir, sibling, RB3_BLACK); \
                rb3_delete_rebalance(head); \
        } else if (rb3_is_red(sibling, right)) { \
                /* outer child of sibling is red */ \
                rb3_connect_null(pnt, right, sleft, rb3_get_color_bit(sibling, left)); \
                rb3_connect(sibling, left, pnt, RB3_BLACK); \
                rb3_connect(gpnt, gdir, sibling, rb3_get_color_bit(gpnt, gdir)); \
                rb3_set_black(sibling, right); \
        } else if (rb3_is_red(sibling, left)) { \
                /* inner child of sibling is red */ \
                sleftleft = rb3_get_child(sleft, left); \
                sleftright = rb3_get_child(sleft, right); \
                rb3_connect_null(pnt, right, sleftleft, RB3_BLACK); \
                rb3_connect_null(sibling, left, sleftright, RB3_BLACK); \
                rb3_connect(sleft, left, pnt, RB3_BLACK); \
                rb3_connect(sleft, right, sibling, RB3_BLACK); \
                rb3_connect(gpnt, gdir, sleft, rb3_get_color_bit(gpnt, gdir)); \
        } else if (rb3_is_red(gpnt, gdir)) { \
                /* parent is red */ \
                rb3_set_red(pnt, right); \
                rb3_set_black(gpnt, gdir); \
        } else { \
                /* all relevant nodes are black */ \
                rb3_set_red(pnt, right); \
                rb3_delete_rebalance(pnt); \
        } \
} \
 \
static RB3_NEVERINLINE \
void rb3_delete_noninternal(struct rb3_head *head) \
{ \
        struct rb3_head *pnt; \
        struct rb3_head *cld; \
        int pdir; \
        int dir; \
 \
        dir = rb3_get_child(head, RB3_RIGHT) ? RB3_RIGHT : RB3_LEFT; \
 \
        pnt = rb3_get_parent(head); \
        cld = rb3_get_child(head, dir); \
        pdir = rb3_get_parent_dir(head); \
 \
        if (!rb3_is_red(pnt, pdir) && !rb3_is_red(head, dir)) \
                /* To be deleted node is black (and child cannot be repainted) \
                 * => height decreased */ \
                rb3_delete_rebalance(head); \
 \
        rb3_connect_null(pnt, pdir, cld, RB3_BLACK); \
} \
 \
static RB3_NEVERINLINE \
void rb3_delete_internal(struct rb3_head *head) \
{ \
        struct rb3_head *subst; \
        struct rb3_head *left; \
        struct rb3_head *right; \
        struct rb3_head *parent; \
        int pdir; \
        int pcol; \
 \
        subst = rb3_get_next_descendant(head); \
        rb3_delete_noninternal(subst); \
        *subst = *head; \
 \
        left = rb3_get_child(head, RB3_LEFT); \
        right = rb3_get_child(head, RB3_RIGHT); \
        parent = rb3_get_parent(head); \
        pdir = rb3_get_parent_dir(head); \
        pcol = rb3_get_color_bit(parent, pdir); \
 \
        if (left) \
                left->parent = RB3_PARENT_PTR(subst, RB3_LEFT); \
        if (right) \
                right->parent = RB3_PARENT_PTR(subst, RB3_RIGHT); \
        parent->child[pdir] = RB3_CHILD_PTR(subst, pcol); \
} \
 \
RB3_API RB3_NEVERINLINE \
void rb3_delete_head(struct rb3_head *head) \
{ \
        if (rb3_has_child(head, RB3_LEFT) && rb3_has_child(head, RB3_RIGHT)) \
                rb3_delete_internal(head); \
        else \
                rb3_delete_noninternal(head); \
 \
        /* We would really like to write \
            *head = (struct rb3_head) {0}; \
          how it's supposed to be, but compilers spew warnings without end. \
 \
          So we go with the slower and bigger-in-codesize version */ \
        head->child[RB3_LEFT] = 0; \
        head->child[RB3_RIGHT] = 0; \
        head->parent = 0; \
} \
 \
/* node-find implementations using code from inline header functions */ \
 \
RB3_API RB3_NEVERINLINE \
struct rb3_head *rb3_find_in_subtree_datacmp(struct rb3_head *subtree, rb3_datacmp cmp, void *data) \
{ \
        return rb3_INLINE_find_in_subtree(subtree, cmp, data); \
} \
 \
RB3_API RB3_NEVERINLINE \
struct rb3_head *rb3_find_parent_in_subtree_datacmp(struct rb3_head *parent, int dir, rb3_datacmp cmp, void *data, struct rb3_head **parent_out, int *dir_out) \
{ \
        return rb3_INLINE_find_parent_in_subtree(parent, dir, cmp, data, parent_out, dir_out); \
} \
 \
/* find, insert, delete with rb3_datacmp */ \
 \
RB3_API RB3_NEVERINLINE \
struct rb3_head *rb3_insert_datacmp(struct rb3_tree *tree, struct rb3_head *head, rb3_datacmp cmp, void *data) \
{ \
        struct rb3_head *found; \
        struct rb3_head *parent; \
        int dir; \
 \
        parent = rb3_get_base(tree); \
        dir = RB3_LEFT; \
        found = rb3_find_parent_in_subtree_datacmp(parent, dir, cmp, data, &parent, &dir); \
        if (found) \
                return found; \
        rb3_insert_below(head, parent, dir); \
        return RB3_NULL; \
} \
 \
RB3_API RB3_NEVERINLINE \
struct rb3_head *rb3_delete_datacmp(struct rb3_tree *tree, rb3_datacmp cmp, void *data) \
{ \
        struct rb3_head *found; \
 \
        found = rb3_find_in_subtree_datacmp(rb3_get_root(tree), cmp, data); \
        if (found) { \
                rb3_delete_head(found); \
                return found; \
        } \
        return RB3_NULL; \
} \
 \
RB3_API RB3_NEVERINLINE \
struct rb3_head *rb3_find_datacmp(struct rb3_tree *tree, rb3_datacmp cmp, void *data) \
{ \
        return rb3_find_in_subtree_datacmp(rb3_get_root(tree), cmp, data); \
} \
 \
/* find, insert, delete with rb3_cmp */ \
 \
RB3_API RB3_NEVERINLINE \
struct rb3_head *rb3_insert(struct rb3_tree *tree, struct rb3_head *head, rb3_cmp cmp) \
{ \
        return rb3_insert_datacmp(tree, head, (rb3_datacmp) cmp, head); \
} \
 \
RB3_API RB3_NEVERINLINE \
struct rb3_head *rb3_delete(struct rb3_tree *tree, rb3_cmp cmp, struct rb3_head *head) \
{ \
        return rb3_delete_datacmp(tree, (rb3_datacmp) cmp, head); \
} \
 \
RB3_API RB3_NEVERINLINE \
struct rb3_head *rb3_find(struct rb3_tree *tree, rb3_cmp cmp, struct rb3_head *head) \
{ \
        return rb3_find_datacmp(tree, (rb3_datacmp) cmp, head); \
} \
 \
/* */ \
 \
RB3_API RB3_NEVERINLINE RB3_COLD \
void rb3_init(struct rb3_tree *tree) \
{ \
        /* We would really like to write \
            *head = (struct rb3_head) {0}; \
          how it's supposed to be, but compilers spew warnings without end. \
 \
          So we go with the slower and bigger-in-codesize version */ \
        tree->base.child[RB3_LEFT] = 0; \
        tree->base.child[RB3_RIGHT] = 0; \
        tree->base.parent = 0; \
} \
 \
RB3_API RB3_NEVERINLINE RB3_COLD \
void rb3_exit(struct rb3_tree *tree) \
{ \
        /* No resources allocated */ \
        (void) tree; \
} \


#define RB3_GEN_IMPL_HEADER_TOTALLY_REAL(RB3_API, RB3_API_STATIC_INLINE, RB3_COLD, RB3_INLINE, RB3_NEVERINLINE)  \
    RB3_GEN_IMPL_TOTALLY_REAL_TYPES(RB3_API, RB3_API_STATIC_INLINE, RB3_COLD, RB3_INLINE, RB3_NEVERINLINE)  \
    RB3_GEN_IMPL_TOTALLY_REAL_BASIC(RB3_API, RB3_API_STATIC_INLINE, RB3_COLD, RB3_INLINE, RB3_NEVERINLINE)  \
    RB3_GEN_IMPL_TOTALLY_REAL_NAVIGATE(RB3_API, RB3_API_STATIC_INLINE, RB3_COLD, RB3_INLINE, RB3_NEVERINLINE)  \
    RB3_GEN_IMPL_TOTALLY_REAL_INTERNAL(RB3_API, RB3_API_STATIC_INLINE, RB3_COLD, RB3_INLINE, RB3_NEVERINLINE)

#define RB3_GEN_IMPL_TOTALLY_REAL(RB3_API, RB3_API_STATIC_INLINE, RB3_COLD, RB3_INLINE, RB3_NEVERINLINE)  \
    RB3_GEN_IMPL_HEADER_TOTALLY_REAL(RB3_API, RB3_API_STATIC_INLINE, RB3_COLD, RB3_INLINE, RB3_NEVERINLINE)  \
    RB3_GEN_IMPL_TOTALLY_REAL_IMPL(RB3_API, RB3_API_STATIC_INLINE, RB3_COLD, RB3_INLINE, RB3_NEVERINLINE)


#define RB3_GEN_TREE_DEFINITION(BASENAME)  \
struct BASENAME {  \
        struct rb3_tree tree;  \
}


#endif  /* RB3_GEN_HEADER */
