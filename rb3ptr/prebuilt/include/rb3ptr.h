/*
Copyright (c) 2017 Jens Stimpfle

Permission is hereby granted, free of charge, to any person obtaining a
copy of this software and associated documentation files (the
"Software"), to deal in the Software without restriction, including
without limitation the rights to use, copy, modify, merge, publish,
distribute, sublicense, and/or sell copies of the Software, and to
permit persons to whom the Software is furnished to do so, subject to
the following conditions:

The above copyright notice and this permission notice shall be included
in all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

*/


/*
 * WARNING:
 *
 * This file was autogenerated with gen-macros.py from files under templates/
 *
 * Autogenerated from git commit 782ad715ac36deba9192955b3a74d032f1011b5d
 */


#ifndef RB3_GEN_HEADER
#define RB3_GEN_HEADER

/*
 * ---------------------------------------------------------------------------
 * Preprocessor definitions
 *
 * This file contains preprocessor definitions used across the project. They
 * are implementation details (not part of the user-facing API).
 * ---------------------------------------------------------------------------
 */

/* don't want no assert.h dependency */
#ifndef RB3_DEBUG
#define _RB3_ASSERT(cond)
#else
#include <assert.h>
#define _RB3_ASSERT assert
#endif

/* don't want no stddef.h dependency */
#ifdef __cplusplus
#define _RB3_NULL 0
#else
#define _RB3_NULL ((void *)0)
#endif
#define _RB3_offsetof(st, m) ((char *)&(((st *)0)->m)-((char *)0))

/* only used in impl */
#define _RB3_DIR_BIT (1<<0)
#define _RB3_COLOR_BIT (1<<1)
#define _RB3_BLACK (0)
#define _RB3_RED (_RB3_COLOR_BIT)
#define _RB3_CHILD_PTR(head, color) ((rb3_ptr)(head) | color)
#define _RB3_PARENT_PTR(head, dir) ((rb3_ptr)(head) | dir)

/*
 * Function attributes. This currently needs "inline", but works both in C99
 * and GNU89 inline models (only C99 supported!).
 */
#define _RB3_API_STATIC_INLINE static inline __attribute__((unused))
#define _RB3_INLINE inline __attribute__((always_inline))
#define _RB3_NEVERINLINE __attribute__((noinline))
#define _RB3_COLD __attribute__((cold))

/*
 * Depending on whether the generic implementation is built as a linkable
 * object or statically in a single file, the meaning of _RB3_API can be either
 * of these two:
 */
#define _RB3_API_EXTERNIMPL extern
#define _RB3_API_STATICIMPL static __attribute__((unused))


/*
 * This is the stuff the user wants to use
 */

#define RB3_GEN_IMPL_HEADER()  \
    _RB3_GEN_IMPL_HEADER_REAL(_RB3_API_EXTERNIMPL)

#define RB3_GEN_IMPL_HEADER_STATIC()  \
    _RB3_GEN_IMPL_HEADER_REAL(_RB3_API_STATICIMPL)

#define RB3_GEN_IMPL()  \
    _RB3_GEN_IMPL_REAL(_RB3_API_EXTERNIMPL)

#define RB3_GEN_IMPL_STATIC()  \
    _RB3_GEN_IMPL_REAL(_RB3_API_STATICIMPL)


#define RB3_GEN_INLINE_PROTO(BASENAME, NODE_TYPE, GET_HEAD, GET_NODE)  \
    _RB3_GEN_INLINE_PROTO_REAL(_RB3_API_EXTERNIMPL, struct BASENAME, NODE_TYPE, GET_HEAD, GET_NODE, BASENAME##_inner_tree, BASENAME##_outer_tree, BASENAME##_init, BASENAME##_exit, BASENAME##_isempty, BASENAME##_get_min, BASENAME##_get_max, BASENAME##_get_prev, BASENAME##_get_next, BASENAME##_get_minmax, BASENAME##_get_prevnext, BASENAME##_get_root, BASENAME##_has_child, BASENAME##_get_child, BASENAME##_get_parent, BASENAME##_get_prev_ancestor, BASENAME##_get_next_ancestor, BASENAME##_get_prev_descendant, BASENAME##_get_next_descendant, BASENAME##_link_and_rebalance, BASENAME##_unlink_and_rebalance, BASENAME##_get_parent_dir, BASENAME##_get_base, BASENAME##_get_containing_tree)

#define RB3_GEN_INLINE_PROTO_STATIC(BASENAME, NODE_TYPE, GET_HEAD, GET_NODE)  \
    _RB3_GEN_INLINE_PROTO_REAL(_RB3_API_STATICIMPL, struct BASENAME, NODE_TYPE, GET_HEAD, GET_NODE, BASENAME##_inner_tree, BASENAME##_outer_tree, BASENAME##_init, BASENAME##_exit, BASENAME##_isempty, BASENAME##_get_min, BASENAME##_get_max, BASENAME##_get_prev, BASENAME##_get_next, BASENAME##_get_minmax, BASENAME##_get_prevnext, BASENAME##_get_root, BASENAME##_has_child, BASENAME##_get_child, BASENAME##_get_parent, BASENAME##_get_prev_ancestor, BASENAME##_get_next_ancestor, BASENAME##_get_prev_descendant, BASENAME##_get_next_descendant, BASENAME##_link_and_rebalance, BASENAME##_unlink_and_rebalance, BASENAME##_get_parent_dir, BASENAME##_get_base, BASENAME##_get_containing_tree)

#define RB3_GEN_NODECMP(BASENAME, SUFFIX, NODE_TYPE, GET_HEAD, GET_NODE, COMPARE_NODE)  \
    _RB3_GEN_NODECMP_REAL(_RB3_API_EXTERNIMPL, struct BASENAME, NODE_TYPE, GET_HEAD, GET_NODE, COMPARE_NODE, BASENAME##_inner_tree, BASENAME##_outer_tree, BASENAME##_init, BASENAME##_exit, BASENAME##_isempty, BASENAME##_get_min, BASENAME##_get_max, BASENAME##_get_prev, BASENAME##_get_next, BASENAME##_get_minmax, BASENAME##_get_prevnext, BASENAME##_get_root, BASENAME##_has_child, BASENAME##_get_child, BASENAME##_get_parent, BASENAME##_get_prev_ancestor, BASENAME##_get_next_ancestor, BASENAME##_get_prev_descendant, BASENAME##_get_next_descendant, BASENAME##_link_and_rebalance, BASENAME##_unlink_and_rebalance, BASENAME##_get_parent_dir, BASENAME##_get_base, BASENAME##_get_containing_tree, BASENAME##_nodecmp##SUFFIX, BASENAME##_find_in_subtree##SUFFIX, BASENAME##_find_parent_in_subtree##SUFFIX, BASENAME##_delete_in_subtree##SUFFIX, BASENAME##_insert_in_subtree##SUFFIX, BASENAME##_find##SUFFIX, BASENAME##_delete##SUFFIX, BASENAME##_insert##SUFFIX)

#define RB3_GEN_NODECMP_STATIC(BASENAME, SUFFIX, NODE_TYPE, GET_HEAD, GET_NODE, COMPARE_NODE)  \
    _RB3_GEN_NODECMP_REAL(_RB3_API_STATICIMPL, struct BASENAME, NODE_TYPE, GET_HEAD, GET_NODE, COMPARE_NODE, BASENAME##_inner_tree, BASENAME##_outer_tree, BASENAME##_init, BASENAME##_exit, BASENAME##_isempty, BASENAME##_get_min, BASENAME##_get_max, BASENAME##_get_prev, BASENAME##_get_next, BASENAME##_get_minmax, BASENAME##_get_prevnext, BASENAME##_get_root, BASENAME##_has_child, BASENAME##_get_child, BASENAME##_get_parent, BASENAME##_get_prev_ancestor, BASENAME##_get_next_ancestor, BASENAME##_get_prev_descendant, BASENAME##_get_next_descendant, BASENAME##_link_and_rebalance, BASENAME##_unlink_and_rebalance, BASENAME##_get_parent_dir, BASENAME##_get_base, BASENAME##_get_containing_tree, BASENAME##_nodecmp##SUFFIX, BASENAME##_find_in_subtree##SUFFIX, BASENAME##_find_parent_in_subtree##SUFFIX, BASENAME##_delete_in_subtree##SUFFIX, BASENAME##_insert_in_subtree##SUFFIX, BASENAME##_find##SUFFIX, BASENAME##_delete##SUFFIX, BASENAME##_insert##SUFFIX)

#define RB3_GEN_NODECMP_PROTO(BASENAME, SUFFIX, NODE_TYPE, GET_HEAD, GET_NODE, COMPARE_NODE)  \
    _RB3_GEN_NODECMP_PROTO_REAL(_RB3_API_EXTERNIMPL, struct BASENAME, NODE_TYPE, GET_HEAD, GET_NODE, COMPARE_NODE, BASENAME##_inner_tree, BASENAME##_outer_tree, BASENAME##_init, BASENAME##_exit, BASENAME##_isempty, BASENAME##_get_min, BASENAME##_get_max, BASENAME##_get_prev, BASENAME##_get_next, BASENAME##_get_minmax, BASENAME##_get_prevnext, BASENAME##_get_root, BASENAME##_has_child, BASENAME##_get_child, BASENAME##_get_parent, BASENAME##_get_prev_ancestor, BASENAME##_get_next_ancestor, BASENAME##_get_prev_descendant, BASENAME##_get_next_descendant, BASENAME##_link_and_rebalance, BASENAME##_unlink_and_rebalance, BASENAME##_get_parent_dir, BASENAME##_get_base, BASENAME##_get_containing_tree, BASENAME##_nodecmp##SUFFIX, BASENAME##_find_in_subtree##SUFFIX, BASENAME##_find_parent_in_subtree##SUFFIX, BASENAME##_delete_in_subtree##SUFFIX, BASENAME##_insert_in_subtree##SUFFIX, BASENAME##_find##SUFFIX, BASENAME##_delete##SUFFIX, BASENAME##_insert##SUFFIX)

#define RB3_GEN_NODECMP_PROTO_STATIC(BASENAME, SUFFIX, NODE_TYPE, GET_HEAD, GET_NODE, COMPARE_NODE)  \
    _RB3_GEN_NODECMP_PROTO_REAL(_RB3_API_STATICIMPL, struct BASENAME, NODE_TYPE, GET_HEAD, GET_NODE, COMPARE_NODE, BASENAME##_inner_tree, BASENAME##_outer_tree, BASENAME##_init, BASENAME##_exit, BASENAME##_isempty, BASENAME##_get_min, BASENAME##_get_max, BASENAME##_get_prev, BASENAME##_get_next, BASENAME##_get_minmax, BASENAME##_get_prevnext, BASENAME##_get_root, BASENAME##_has_child, BASENAME##_get_child, BASENAME##_get_parent, BASENAME##_get_prev_ancestor, BASENAME##_get_next_ancestor, BASENAME##_get_prev_descendant, BASENAME##_get_next_descendant, BASENAME##_link_and_rebalance, BASENAME##_unlink_and_rebalance, BASENAME##_get_parent_dir, BASENAME##_get_base, BASENAME##_get_containing_tree, BASENAME##_nodecmp##SUFFIX, BASENAME##_find_in_subtree##SUFFIX, BASENAME##_find_parent_in_subtree##SUFFIX, BASENAME##_delete_in_subtree##SUFFIX, BASENAME##_insert_in_subtree##SUFFIX, BASENAME##_find##SUFFIX, BASENAME##_delete##SUFFIX, BASENAME##_insert##SUFFIX)

/* (END stuff) */


/*
 * ===========================================================================
 * SORRY FOR THIS MESS
 *
 * These macros are only for implementation. Not part of the API.
 * ===========================================================================
 */

#define _RB3_GEN_INLINE_PROTO_REAL(_RB3_API, OUTER_TREE_TYPE, NODE_TYPE, GET_HEAD, GET_NODE, INNER_TREE, OUTER_TREE, init, exit, isempty, get_min, get_max, get_prev, get_next, get_minmax, get_prevnext, get_root, has_child, get_child, get_parent, get_prev_ancestor, get_next_ancestor, get_prev_descendant, get_next_descendant, link_and_rebalance, unlink_and_rebalance, get_parent_dir, get_base, get_containing_tree)  \
_RB3_API_STATIC_INLINE \
struct rb3_tree *INNER_TREE(OUTER_TREE_TYPE *tree) \
{ \
        return (struct rb3_tree *) tree; \
} \
 \
_RB3_API_STATIC_INLINE \
OUTER_TREE_TYPE *OUTER_TREE(struct rb3_tree *tree) \
{ \
        return (OUTER_TREE_TYPE *) tree; \
} \
 \
_RB3_API_STATIC_INLINE \
void init(OUTER_TREE_TYPE *tree) \
{ \
        rb3_init(INNER_TREE(tree)); \
} \
 \
_RB3_API_STATIC_INLINE \
void exit(OUTER_TREE_TYPE *tree) \
{ \
        rb3_exit(INNER_TREE(tree)); \
} \
 \
_RB3_API_STATIC_INLINE \
int isempty(OUTER_TREE_TYPE *tree) \
{ \
        return rb3_isempty(INNER_TREE(tree)); \
} \
 \
_RB3_API_STATIC_INLINE \
NODE_TYPE *get_min(OUTER_TREE_TYPE *tree) \
{ \
        return GET_NODE(rb3_get_min(INNER_TREE(tree))); \
} \
 \
_RB3_API_STATIC_INLINE \
NODE_TYPE *get_max(OUTER_TREE_TYPE *tree) \
{ \
        return GET_NODE(rb3_get_max(INNER_TREE(tree))); \
} \
 \
_RB3_API_STATIC_INLINE \
NODE_TYPE *get_prev(NODE_TYPE *node) \
{ \
        return GET_NODE(rb3_get_prev(GET_HEAD(node))); \
} \
 \
_RB3_API_STATIC_INLINE \
NODE_TYPE *get_next(NODE_TYPE *node) \
{ \
        return GET_NODE(rb3_get_next(GET_HEAD(node))); \
} \
 \
_RB3_API_STATIC_INLINE \
NODE_TYPE *get_minmax(OUTER_TREE_TYPE *tree, int dir) \
{ \
        return GET_NODE(rb3_get_minmax(INNER_TREE(tree), dir)); \
} \
 \
_RB3_API_STATIC_INLINE \
NODE_TYPE *get_prevnext(NODE_TYPE *node, int dir) \
{ \
        return GET_NODE(rb3_get_prevnext(GET_HEAD(node), dir)); \
} \
 \
/* \
 * Delete a node that is known to be linked in a tree. \
 * \
 * This is deletion with a refined equivalence relation where nodes are only \
 * equal iff their memory addresses are identical. \
 */ \
_RB3_API_STATIC_INLINE \
void unlink_and_rebalance(NODE_TYPE *node) \
{ \
        rb3_unlink_and_rebalance(GET_HEAD(node)); \
} \
 \
/* \
 * -------------------------- \
 * Binary Search Tree stuff \
 * -------------------------- \
 */ \
 \
_RB3_API_STATIC_INLINE \
NODE_TYPE *get_root(OUTER_TREE_TYPE *tree) \
{ \
        return GET_NODE(rb3_get_root(INNER_TREE(tree))); \
} \
 \
_RB3_API_STATIC_INLINE \
int has_child(NODE_TYPE *node, int dir) \
{ \
        return rb3_has_child(GET_HEAD(node), dir); \
} \
 \
_RB3_API_STATIC_INLINE \
NODE_TYPE *get_child(NODE_TYPE *node, int dir) \
{ \
        return GET_NODE(rb3_get_child(GET_HEAD(node), dir)); \
} \
 \
_RB3_API_STATIC_INLINE \
NODE_TYPE *get_parent(NODE_TYPE *node) \
{ \
        struct rb3_head *parent; \
 \
        parent = rb3_get_parent(GET_HEAD(node)); \
        if (rb3_is_base(parent)) \
                return (NODE_TYPE *) 0; \
        return GET_NODE(parent); \
} \
 \
_RB3_API_STATIC_INLINE \
NODE_TYPE *get_prev_ancestor(NODE_TYPE *node) \
{ \
        return GET_NODE(rb3_get_prev_ancestor(GET_HEAD(node))); \
} \
 \
_RB3_API_STATIC_INLINE \
NODE_TYPE *get_next_ancestor(NODE_TYPE *node) \
{ \
        return GET_NODE(rb3_get_next_ancestor(GET_HEAD(node))); \
} \
 \
_RB3_API_STATIC_INLINE \
NODE_TYPE *get_prev_descendant(NODE_TYPE *node) \
{ \
        return GET_NODE(rb3_get_prev_descendant(GET_HEAD(node))); \
} \
 \
_RB3_API_STATIC_INLINE \
NODE_TYPE *get_next_descendant(NODE_TYPE *node) \
{ \
        return GET_NODE(rb3_get_next_descendant(GET_HEAD(node))); \
} \
 \
_RB3_API_STATIC_INLINE \
int get_parent_dir(NODE_TYPE *node) \
{ \
        return rb3_get_parent_dir(GET_HEAD(node)); \
} \
 \
_RB3_API_STATIC_INLINE \
OUTER_TREE_TYPE *get_containing_tree(NODE_TYPE *node) \
{ \
        return OUTER_TREE(rb3_get_containing_tree(GET_HEAD(node))); \
} \


#define _RB3_GEN_NODECMP_PROTO_REAL(_RB3_API, OUTER_TREE_TYPE, NODE_TYPE, GET_HEAD, GET_NODE, COMPARE_NODE, INNER_TREE, OUTER_TREE, init, exit, isempty, get_min, get_max, get_prev, get_next, get_minmax, get_prevnext, get_root, has_child, get_child, get_parent, get_prev_ancestor, get_next_ancestor, get_prev_descendant, get_next_descendant, link_and_rebalance, unlink_and_rebalance, get_parent_dir, get_base, get_containing_tree, nodecmp, find_in_subtree, find_parent_in_subtree, delete_in_subtree, insert_in_subtree, find, delete, insert)  \
/** \
 * Find `node` in `tree` using the comparison function handed to the macro \
 * that generates this function. \
 */ \
_RB3_API \
NODE_TYPE *find(OUTER_TREE_TYPE *tree, NODE_TYPE *node); \
 \
/** \
 * Delete `node` from `tree` using the comparison function handed to the macro \
 * that generates this function. \
 */ \
_RB3_API \
NODE_TYPE *delete(OUTER_TREE_TYPE *tree, NODE_TYPE *node); \
 \
/** \
 * Insert `node` into `tree` using the comparison function handed to the macro \
 * that generates this function. \
 */ \
_RB3_API \
NODE_TYPE *insert(OUTER_TREE_TYPE *tree, NODE_TYPE *node); \
 \
 \
/* \
 * --------------------------------------------------------------------------- \
 * Internal stuff (probably not useful) \
 * --------------------------------------------------------------------------- \
 */ \
 \
/** \
 * Find a node in the subtree indicated by `subtree` (inclusively). \
 */ \
_RB3_API \
NODE_TYPE *find_in_subtree(NODE_TYPE *subtree, NODE_TYPE *node); \
 \
/** \
 * Find insertion point in subtree. The subtree is indicated by its parent and \
 * the child direction in which the parent links the subtree. \
 * \
 * Parent must be non-NULL, but it could be the base (and the latter is the \
 * reason why it can't be a NODE_TYPE but must be a struct rb3_head). \
 */ \
_RB3_API \
NODE_TYPE *find_parent_in_subtree(struct rb3_head *parent, int dir, NODE_TYPE *node, struct rb3_head **parent_out, int *dir_out); \


#define _RB3_GEN_NODECMP_REAL(_RB3_API, OUTER_TREE_TYPE, NODE_TYPE, GET_HEAD, GET_NODE, COMPARE_NODE, INNER_TREE, OUTER_TREE, init, exit, isempty, get_min, get_max, get_prev, get_next, get_minmax, get_prevnext, get_root, has_child, get_child, get_parent, get_prev_ancestor, get_next_ancestor, get_prev_descendant, get_next_descendant, link_and_rebalance, unlink_and_rebalance, get_parent_dir, get_base, get_containing_tree, nodecmp, find_in_subtree, find_parent_in_subtree, delete_in_subtree, insert_in_subtree, find, delete, insert)  \
/* \
 * --------------------------------------------------------------------------- \
 * Nodecmp \
 * \
 * This file implements the typesafe wrapper for comparison related functions \
 * (find, insert, delete). \
 * --------------------------------------------------------------------------- \
 */ \
 \
_RB3_API_STATIC_INLINE \
int nodecmp(struct rb3_head *a, NODE_TYPE *b) \
{ \
        return COMPARE_NODE(GET_NODE(a), b); \
} \
 \
_RB3_API _RB3_NEVERINLINE \
NODE_TYPE *find_in_subtree(NODE_TYPE *subtree, NODE_TYPE *node) \
{ \
        return GET_NODE(rb3_INLINE_find_in_subtree(GET_HEAD(subtree), (rb3_cmp) nodecmp, GET_HEAD(node))); \
} \
 \
_RB3_API _RB3_NEVERINLINE \
NODE_TYPE *find_parent_in_subtree(struct rb3_head *parent, int dir, NODE_TYPE *node, struct rb3_head **parent_out, int *dir_out) \
{ \
        return GET_NODE(rb3_INLINE_find_parent_in_subtree(parent, dir, (rb3_cmp) nodecmp, node, parent_out, dir_out)); \
} \
 \
_RB3_API \
NODE_TYPE *find(OUTER_TREE_TYPE *tree, NODE_TYPE *node) \
{ \
        return find_in_subtree(get_root(tree), node); \
} \
 \
_RB3_API \
NODE_TYPE *delete(OUTER_TREE_TYPE *tree, NODE_TYPE *node) \
{ \
        NODE_TYPE *found; \
 \
        found = find_in_subtree(get_root(tree), node); \
        if (found) \
                rb3_unlink_and_rebalance(GET_HEAD(found)); \
        return found; \
} \
 \
_RB3_API \
NODE_TYPE *insert(OUTER_TREE_TYPE *tree, NODE_TYPE *node) \
{ \
        NODE_TYPE *found; \
        struct rb3_head *parent; \
        int dir; \
 \
        found = find_parent_in_subtree(&INNER_TREE(tree)->base, RB3_LEFT, node, &parent, &dir); \
        if (!found) \
                rb3_link_and_rebalance(GET_HEAD(node), parent, dir); \
        return found; \
} \


#define _RB3_GEN_IMPL_REAL_TYPES(_RB3_API)  \
/* \
 * --------------------------------------------------------------------------- \
 * Types \
 * \
 * This file provides the typedefs and struct definitions that are required \
 * for the type-agnostic API. \
 * --------------------------------------------------------------------------- \
 */ \
 \
/** \
 * This type is used to efficiently store a pointer (at least 4-byte aligned) \
 * and some more information in the unused low bits. \
 */ \
typedef unsigned long rb3_ptr; \
 \
/** \
 * Directions for navigation in the tree. \
 */ \
enum { \
        RB3_LEFT = 0, \
        RB3_RIGHT = 1, \
}; \
 \
/** \
 * Node type for 3-pointer Red-black trees. \
 */ \
struct rb3_head { \
        /* \
         * Left, right, and parent pointers. \
         * \
         * The left and right pointers have additional color bits. \
         * \
         * The parent pointer contains a direction bit indicating the direction \
         * to this child. \
         */ \
        rb3_ptr child[2]; \
        rb3_ptr parent; \
}; \
 \
/** \
 * Tree type. It's just a fake base head that is wrapped for type safety and \
 * future extensibility. \
 */ \
struct rb3_tree { \
        struct rb3_head base; \
}; \
 \
/** \
 * User-provided comparison function. It is used during tree searches. \
 * At each visited node, the function is called with that node as first \
 * argument and some additional user-provided data. \
 * \
 * It should returns a value less than, equal to, or greater than, 0, \
 * depending on whether the node compares less than, equal to, or greater \
 * than, the user-provided data. \
 */ \
typedef int (*rb3_cmp)(struct rb3_head *head, void *data); \
 \
/** \
 * Get fake base of tree. \
 * \
 * Warning: the special base element is never embedded in a client payload \
 * structure. It's just a link to host the real root of the tree as its left \
 * child. \
 */ \
_RB3_API_STATIC_INLINE \
struct rb3_head *rb3_get_base(struct rb3_tree *tree); \
 \
/** \
 * Test if given head is fake base of tree. \
 */ \
_RB3_API_STATIC_INLINE \
int rb3_is_base(struct rb3_head *head); \
 \
/** \
 * Check if a non-base head is linked in a (any) tree. \
 * \
 * Time complexity: O(1) \
 */ \
_RB3_API_STATIC_INLINE \
int rb3_is_node_linked(struct rb3_head *head); \
 \
/** \
 * Get direction from parent to child by testing the direction. \
 * \
 * Return RB3_LEFT or RB3_RIGHT, depending on whether this node is the left or \
 * right child of its parent node. If the given node is the root node, \
 * RB3_LEFT is returned. (Technically the root node is the left child of the \
 * base node). \
 * \
 * This is more convenient and (in theory) more efficient than getting the \
 * parent and testing its left and right child. \
 */ \
_RB3_API_STATIC_INLINE \
int rb3_get_parent_dir(struct rb3_head *head); \
 \
/** \
 * Get parent head, or NULL if given node is the base node. \
 * \
 * Note that normally you don't want to visit the base node but stop already \
 * at the root node. \
 * \
 * Time complexity: O(1) \
 */ \
_RB3_API_STATIC_INLINE \
struct rb3_head *rb3_get_parent(struct rb3_head *head); \
 \
/* \
 * Test if a (left or right) child exists. \
 * \
 * This is slightly more efficient than calling rb3_get_child() and comparing \
 * to NULL. \
 * \
 * Time complexity: O(1) \
 */ \
_RB3_API_STATIC_INLINE \
int rb3_has_child(struct rb3_head *head, int dir); \
 \
/** \
 * Get child in given direction, or NULL if there is no such child. `dir` \
 * must be RB3_LEFT or RB3_RIGHT. \
 * \
 * Time complexity: O(1) \
 */ \
_RB3_API_STATIC_INLINE \
struct rb3_head *rb3_get_child(struct rb3_head *head, int dir); \
 \
/* \
 * --------------------------------------------------------------------------- \
 * Inline implementations \
 * --------------------------------------------------------------------------- \
 */ \
 \
_RB3_API_STATIC_INLINE \
struct rb3_head *rb3_get_base(struct rb3_tree *tree) \
{ \
        return &tree->base; \
} \
 \
_RB3_API_STATIC_INLINE \
int rb3_is_base(struct rb3_head *head) \
{ \
        /* \
         * We could check for the parent pointer being null, but by having \
         * a special sentinel right child value instead, we can make this \
         * function distinguish the base from unlinked pointers as well. \
         * \
         * A side effect is that this breaks programs with trees that are not \
         * initialized with rb3_init(), which could be a good or a bad thing, \
         * I don't know. \
         */ \
	return head->child[RB3_RIGHT] == 3; \
} \
 \
_RB3_API_STATIC_INLINE \
int rb3_is_node_linked(struct rb3_head *head) \
{ \
        return head->parent != 0; \
} \
 \
_RB3_API_STATIC_INLINE \
int rb3_get_parent_dir(struct rb3_head *head) \
{ \
        return head->parent & 1; \
} \
 \
_RB3_API_STATIC_INLINE \
struct rb3_head *rb3_get_parent(struct rb3_head *head) \
{ \
        return (struct rb3_head *)(head->parent & ~3); \
} \
 \
_RB3_API_STATIC_INLINE \
int rb3_has_child(struct rb3_head *head, int dir) \
{ \
        return head->child[dir] != 0; \
} \
 \
_RB3_API_STATIC_INLINE \
struct rb3_head *rb3_get_child(struct rb3_head *head, int dir) \
{ \
        return (struct rb3_head *)((head->child[dir]) & ~3); \
} \


#define _RB3_GEN_IMPL_REAL_INTERNAL(_RB3_API)  \
/* \
 * --------------------------------------------------------------------------- \
 * Internal API \
 * \
 * These functions expose some of the more stable implementation details that \
 * might be useful in other places. They are generally unsafe to use. Make \
 * sure to read the assumptions that must hold before calling them. \
 * --------------------------------------------------------------------------- \
 */ \
 \
/** \
 * Like rb3_find() but starts at the given subtree represented by a link head \
 * (which may be NULL) instead of at the root of the tree. \
 */ \
_RB3_API \
struct rb3_head *rb3_find_in_subtree(struct rb3_head *subtree, rb3_cmp, void *data); \
 \
/** \
 * Find suitable insertion point for a new node in a subtree, directed by the \
 * given search function. The subtree is given by its parent node `parent` and \
 * child direction `dir`. The insertion point and its child direction are \
 * returned in `parent_out` and `dir_out`. \
 * \
 * If the searched node is already in the tree (the compare function returns \
 * 0), it is returned. In this case `parent_out` and `dir_out` are left \
 * untouched. Otherwise NULL is returned. \
 */ \
_RB3_API \
struct rb3_head *rb3_find_parent_in_subtree(struct rb3_head *parent, int dir, rb3_cmp cmp, void *data, struct rb3_head **parent_out, int *dir_out); \
 \
 \
/* \
 * Inline implementations \
 */ \
 \
/* this interface is meant for code generation, not for casual consumption */ \
_RB3_API_STATIC_INLINE \
struct rb3_head *rb3_INLINE_find_in_subtree(struct rb3_head *subtree, rb3_cmp cmp, void *data) \
{ \
        struct rb3_head *head; \
        int dir; \
        int r; \
 \
        head = subtree; \
        while (head) { \
                r = cmp(head, data); \
                if (r < 0) \
                        dir = RB3_RIGHT; \
                else if (r > 0) \
                        dir = RB3_LEFT; \
                else \
                        return head; \
                head = rb3_get_child(head, dir); \
        } \
        return _RB3_NULL; \
} \
 \
/* this interface is meant for code generation, not for casual consumption */ \
_RB3_API_STATIC_INLINE \
struct rb3_head *rb3_INLINE_find_parent_in_subtree(struct rb3_head *parent, int dir, rb3_cmp cmp, void *data, struct rb3_head **parent_out, int *dir_out) \
{ \
        struct rb3_head *head; \
        int r; \
 \
        _RB3_ASSERT(parent != _RB3_NULL); \
        do { \
                head = rb3_get_child(parent, dir); \
                if (!head) \
                        break; \
                r = cmp(head, data); \
                if (r < 0) \
                        dir = RB3_RIGHT; \
                else if (r > 0) \
                        dir = RB3_LEFT; \
                else \
                        return head; \
                parent = head; \
        } while (head); \
        *parent_out = parent; \
        *dir_out = dir; \
        return _RB3_NULL; \
} \


#define _RB3_GEN_IMPL_REAL_NAVIGATE(_RB3_API)  \
/* \
 * --------------------------------------------------------------------------- \
 * Navigational API \
 * \
 * These functions provide advanced functionality for navigation in a \
 * binary search tree. \
 * --------------------------------------------------------------------------- \
 */ \
 \
/** \
 * Get topmost element of tree (or NULL if empty) \
 * \
 * Time complexity: O(1) \
 */ \
_RB3_API_STATIC_INLINE \
struct rb3_head *rb3_get_root(struct rb3_tree *tree); \
 \
/** \
 * Get previous in-order descendant (maximal descendant node that sorts before \
 * the given element) or NULL if no such element is in the tree. \
 * \
 * Time complexity: O(log n) \
 */ \
_RB3_API_STATIC_INLINE \
struct rb3_head *rb3_get_prev_descendant(struct rb3_head *head); \
 \
/** \
 * Get next in-order descendant (minimal descendant node that sorts after the \
 * given element) or NULL if no such element is in the tree. \
 * \
 * Time complexity: O(log n) \
 */ \
_RB3_API_STATIC_INLINE \
struct rb3_head *rb3_get_next_descendant(struct rb3_head *head); \
 \
/** \
 * Get previous in-order ancestor (maximal ancestor node that sorts before the \
 * given element) or NULL if no such element is in the tree. \
 * \
 * Time complexity: O(log n) \
 */ \
_RB3_API_STATIC_INLINE \
struct rb3_head *rb3_get_prev_ancestor(struct rb3_head *head); \
 \
/** \
 * Get next in-order ancestor (minimal ancestor node that sorts after the \
 * given element) or NULL if no such element is in the tree. \
 * \
 * Time complexity: O(log n) \
 */ \
_RB3_API_STATIC_INLINE \
struct rb3_head *rb3_get_next_ancestor(struct rb3_head *head); \
 \
/** \
 * Get previous or next in-order descendant, depending on the value of `dir` \
 * (RB3_LEFT or RB3_RIGHT). \
 * \
 * Time complexity: O(log n) \
 */ \
_RB3_API \
struct rb3_head *rb3_get_prevnext_descendant(struct rb3_head *head, int dir); \
 \
/** \
 * Get previous or next in-order ancestor, depending on the value of `dir` \
 * (RB3_LEFT or RB3_RIGHT). \
 * \
 * Time complexity: O(log n) \
 */ \
_RB3_API \
struct rb3_head *rb3_get_prevnext_ancestor(struct rb3_head *head, int dir); \
 \
/* \
 * Inline implementations \
 */ \
 \
_RB3_API_STATIC_INLINE \
struct rb3_head *rb3_get_root(struct rb3_tree *tree) \
{ \
        return rb3_get_child(&tree->base, RB3_LEFT); \
} \
 \
_RB3_API_STATIC_INLINE \
struct rb3_head *rb3_get_prev_descendant(struct rb3_head *head) \
{ \
        return rb3_get_prevnext_descendant(head, RB3_LEFT); \
} \
 \
_RB3_API_STATIC_INLINE \
struct rb3_head *rb3_get_next_descendant(struct rb3_head *head) \
{ \
        return rb3_get_prevnext_descendant(head, RB3_RIGHT); \
} \
 \
_RB3_API_STATIC_INLINE \
struct rb3_head *rb3_get_prev_ancestor(struct rb3_head *head) \
{ \
        return rb3_get_prevnext_ancestor(head, RB3_LEFT); \
} \
 \
_RB3_API_STATIC_INLINE \
struct rb3_head *rb3_get_next_ancestor(struct rb3_head *head) \
{ \
        return rb3_get_prevnext_ancestor(head, RB3_RIGHT); \
} \


#define _RB3_GEN_IMPL_REAL_BASIC(_RB3_API)  \
/* \
 * --------------------------------------------------------------------------- \
 * BASIC API \
 * \
 * These functions provide basic usability as an abstract ordered container. \
 * Often they are all you need to know. \
 * --------------------------------------------------------------------------- \
 */ \
 \
/** \
 * Initialize an rb3_tree. \
 * \
 * Time complexity: O(1) \
 */ \
_RB3_API \
void rb3_init(struct rb3_tree *tree); \
 \
/** \
 * Free resources allocated by an rb3_tree (currently none, but this could \
 * change). \
 */ \
_RB3_API \
void rb3_exit(struct rb3_tree *tree); \
 \
/** \
 * Check if tree is empty. \
 * \
 * Time complexity: O(1) \
 */ \
_RB3_API_STATIC_INLINE \
int rb3_isempty(struct rb3_tree *tree); \
 \
/** \
 * Get minimum (leftmost) element, or NULL if tree is empty. \
 * \
 * Time complexity: O(log n) \
 */ \
_RB3_API_STATIC_INLINE \
struct rb3_head *rb3_get_min(struct rb3_tree *tree); \
 \
/** \
 * Get maximum (rightmost) element, or NULL if tree is empty \
 * \
 * Time complexity: O(log n) \
 */ \
_RB3_API_STATIC_INLINE \
struct rb3_head *rb3_get_max(struct rb3_tree *tree); \
 \
/** \
 * Get previous in-order node (maximal node in the tree that sorts before the \
 * given element) or NULL if no such element is in the tree. \
 * \
 * Time complexity: O(log n), amortized over sequential scan: O(1) \
 */ \
_RB3_API_STATIC_INLINE \
struct rb3_head *rb3_get_prev(struct rb3_head *head); \
 \
/** \
 * Get next in-order node (minimal node in the tree that sorts after the given \
 * element) or NULL if no such element is in the tree. \
 * \
 * Time complexity: O(log n), amortized over sequential scan: O(1) \
 */ \
_RB3_API_STATIC_INLINE \
struct rb3_head *rb3_get_next(struct rb3_head *head); \
 \
/** \
 * Get minimum or maximum, depending on the value of `dir` (RB3_LEFT or \
 * RB3_RIGHT) \
 * \
 * Time complexity: O(log n) \
 */ \
_RB3_API \
struct rb3_head *rb3_get_minmax(struct rb3_tree *tree, int dir); \
 \
/** \
 * Get previous or next in-order node, depending on the value of `dir`. \
 * \
 * Time complexity: O(log n), amortized over sequential scan: O(1) \
 */ \
_RB3_API \
struct rb3_head *rb3_get_prevnext(struct rb3_head *head, int dir); \
 \
/** \
 * Find a node in `tree` using `cmp` to direct the search. At each visited \
 * node in the tree `cmp` is called with that node and `data` as arguments. \
 * If a node that compares equal is found, it is returned. Otherwise, NULL is \
 * returned. \
 * \
 * Time complexity: O(log n) \
 */ \
_RB3_API \
struct rb3_head *rb3_find(struct rb3_tree *tree, rb3_cmp cmp, void *data); \
 \
/** \
 * Find a suitable insertion point for a new node in `tree` using `cmp` and \
 * `data` to direct the search. At each visited node in the tree `cmp` is \
 * called with that node and `data` as arguments. If a node that compares \
 * equal is found, it is returned. Otherwise, NULL is returned and the \
 * insertion point is returned as parent node and child direction in \
 * `parent_out` and `dir_out`. \
 * \
 * Time complexity: O(log n) \
 */ \
_RB3_API \
struct rb3_head *rb3_find_parent(struct rb3_tree *tree, rb3_cmp cmp, void *data, struct rb3_head **parent_out, int *dir_out); \
 \
/** \
 * Link `head` into `tree` below another node in the given direction (RB3_LEFT \
 * or RB3_RIGHT). The new node must replace a leaf. You can use \
 * rb3_find_parent() to find the insertion point. \
 * \
 * `head` must not be linked into another tree when this function is called. \
 * \
 * Time complexity: O(log n) \
 */ \
_RB3_API \
void rb3_link_and_rebalance(struct rb3_head *head, struct rb3_head *parent, int dir); \
 \
/** \
 * Unlink `head` from its current tree. \
 * \
 * Time complexity: O(log n) \
 */ \
_RB3_API \
void rb3_unlink_and_rebalance(struct rb3_head *head); \
 \
/** \
 * Replace `head` with `newhead`. `head` must be linked in a tree and \
 * `newhead` must not be linked in a tree. \
 */ \
_RB3_API \
void rb3_replace(struct rb3_head *head, struct rb3_head *newhead); \
 \
/** \
 * Insert `head` into `tree` using `cmp` and `data` to direct the search. At \
 * each visited node in the tree `cmp` is called with that node and `data` as \
 * arguments (in that order). If a node that compares equal is found, it is \
 * returned. Otherwise, `head` is inserted into the tree and NULL is \
 * returned. \
 * \
 * Time complexity: O(log n) \
 */ \
_RB3_API \
struct rb3_head *rb3_insert(struct rb3_tree *tree, struct rb3_head *head, rb3_cmp cmp, void *data); \
 \
/** \
 * Find and delete a node from `tree` using `cmp` to direct the search. At \
 * each visited node in the tree `cmp` is called with that node and `head` as \
 * arguments (in that order). If a node that compares equal is found, it is \
 * unlinked from the tree and returned. Otherwise, NULL is returned. \
 * \
 * Time complexity: O(log n) \
 */ \
_RB3_API \
struct rb3_head *rb3_delete(struct rb3_tree *tree, rb3_cmp cmp, void *data); \
 \
/** \
 * Given a node that is known to be linked in _some_ tree, find that tree. \
 * \
 * This involves a little hackery with offsetof(3) \
 */ \
_RB3_API \
struct rb3_tree *rb3_get_containing_tree(struct rb3_head *head); \
 \
 \
/* \
 * Inline implementations \
 */ \
 \
_RB3_API_STATIC_INLINE \
int rb3_isempty(struct rb3_tree *tree) \
{ \
        return !rb3_has_child(rb3_get_base(tree), RB3_LEFT); \
} \
 \
_RB3_API_STATIC_INLINE \
struct rb3_head *rb3_get_min(struct rb3_tree *tree) \
{ \
        return rb3_get_minmax(tree, RB3_LEFT); \
} \
 \
_RB3_API_STATIC_INLINE \
struct rb3_head *rb3_get_max(struct rb3_tree *tree) \
{ \
        return rb3_get_minmax(tree, RB3_RIGHT); \
} \
 \
_RB3_API_STATIC_INLINE \
struct rb3_head *rb3_get_prev(struct rb3_head *head) \
{ \
        return rb3_get_prevnext(head, RB3_LEFT); \
} \
 \
_RB3_API_STATIC_INLINE \
struct rb3_head *rb3_get_next(struct rb3_head *head) \
{ \
        return rb3_get_prevnext(head, RB3_RIGHT); \
} \


#define _RB3_GEN_IMPL_REAL_IMPL(_RB3_API)  \
/* \
 * --------------------------------------------------------------------------- \
 * Implementation \
 * \
 * This file provides the (key)type-agnostic tree code that can be shared \
 * across all tree instances (with differing key types). \
 * --------------------------------------------------------------------------- \
 */ \
 \
static _RB3_INLINE \
struct rb3_head *rb3_get_black_child(struct rb3_head *head, int dir) \
{ \
        return (struct rb3_head *) head->child[dir]; \
} \
 \
static _RB3_INLINE \
int rb3_get_color_bit(struct rb3_head *head, int dir) \
{ \
        return head->child[dir] & _RB3_COLOR_BIT; \
} \
 \
static _RB3_INLINE \
int rb3_is_red(struct rb3_head *head, int dir) \
{ \
        return rb3_get_color_bit(head, dir) != 0; \
} \
 \
static _RB3_INLINE \
void rb3_set_red(struct rb3_head *head, int dir) \
{ \
        head->child[dir] |= _RB3_COLOR_BIT; \
} \
 \
static _RB3_INLINE \
void rb3_set_black(struct rb3_head *head, int dir) \
{ \
        head->child[dir] &= ~_RB3_COLOR_BIT; \
} \
 \
static _RB3_INLINE \
void rb3_connect(struct rb3_head *head, int dir, struct rb3_head *child, int color) \
{ \
        head->child[dir] = _RB3_CHILD_PTR(child, color); \
        child->parent = _RB3_PARENT_PTR(head, dir); \
} \
 \
static _RB3_INLINE \
void rb3_connect_null(struct rb3_head *head, int dir, struct rb3_head *child, int color) \
{ \
        head->child[dir] = _RB3_CHILD_PTR(child, color); \
        if (child) \
                child->parent = _RB3_PARENT_PTR(head, dir); \
} \
 \
_RB3_API \
struct rb3_tree *rb3_get_containing_tree(struct rb3_head *head) \
{ \
        while (rb3_get_parent(head)) \
                head = rb3_get_parent(head); \
        return (struct rb3_tree *) ((char *) head - (_RB3_offsetof(struct rb3_head, child[0]))); \
} \
 \
static _RB3_NEVERINLINE \
struct rb3_head *rb3_get_minmax_in_subtree(struct rb3_head *head, int dir) \
{ \
        if (!head) \
                return _RB3_NULL; \
        while (rb3_has_child(head, dir)) \
                head = rb3_get_child(head, dir); \
        return head; \
} \
 \
_RB3_API \
struct rb3_head *rb3_get_minmax(struct rb3_tree *tree, int dir) \
{ \
        return rb3_get_minmax_in_subtree(rb3_get_root(tree), dir); \
} \
 \
_RB3_API \
struct rb3_head *rb3_get_prevnext_descendant(struct rb3_head *head, int dir) \
{ \
        return rb3_get_minmax_in_subtree(rb3_get_child(head, dir), !dir); \
} \
 \
_RB3_API \
struct rb3_head *rb3_get_prevnext_ancestor(struct rb3_head *head, int dir) \
{ \
        /* \
         * Note: the direction is "reversed" for our purposes here, since \
         * the bit indicates the direction from the parent to `head` \
         */ \
        while (head && rb3_get_parent_dir(head) == dir) { \
                head = rb3_get_parent(head); \
        } \
        if (head) { \
                head = rb3_get_parent(head); \
                if (!head || rb3_is_base(head)) \
                        return NULL; \
                return head; \
        } \
        return NULL; \
} \
 \
_RB3_API \
struct rb3_head *rb3_get_prevnext(struct rb3_head *head, int dir) \
{ \
        if (rb3_has_child(head, dir)) \
                return rb3_get_prevnext_descendant(head, dir); \
        else \
                return rb3_get_prevnext_ancestor(head, dir); \
} \
 \
/* insert implementation */ \
 \
static _RB3_NEVERINLINE \
void rb3_insert_rebalance(struct rb3_head *head) \
{ \
        struct rb3_head *pnt; \
        struct rb3_head *gpnt; \
        struct rb3_head *ggpnt; \
        int left; \
        int right; \
        int gdir; \
        int ggdir; \
 \
        if (!rb3_get_parent(rb3_get_parent(head))) { \
                rb3_set_black(rb3_get_parent(head), RB3_LEFT); \
                return; \
        } \
 \
        if (!rb3_is_red(rb3_get_parent(rb3_get_parent(head)), rb3_get_parent_dir(rb3_get_parent(head)))) \
                /* parent is black */ \
                return; \
 \
        /* \
         * Since parent is red parent can't be the root. \
         * So we have at least a grandparent node, and grand-grandparent \
         * is either a real node or the base head. \
         */ \
        pnt = rb3_get_parent(head); \
        gpnt = rb3_get_parent(pnt); \
        ggpnt = rb3_get_parent(gpnt); \
        left = rb3_get_parent_dir(head); \
        right = !rb3_get_parent_dir(head); \
        gdir = rb3_get_parent_dir(pnt); \
        ggdir = rb3_get_parent_dir(gpnt); \
 \
        if (rb3_is_red(gpnt, !gdir)) { \
                /* uncle and parent are both red */ \
                rb3_set_red(ggpnt, ggdir); \
                rb3_set_black(gpnt, RB3_LEFT); \
                rb3_set_black(gpnt, RB3_RIGHT); \
                rb3_insert_rebalance(gpnt); \
        } else if (gdir == right) { \
                rb3_connect_null(pnt, left, rb3_get_black_child(head, right), _RB3_BLACK); \
                rb3_connect_null(gpnt, right, rb3_get_black_child(head, left), _RB3_BLACK); \
                rb3_connect(head, left, gpnt, _RB3_RED); \
                rb3_connect(head, right, pnt, _RB3_RED); \
                rb3_connect(ggpnt, ggdir, head, _RB3_BLACK); \
        } else { \
                rb3_connect_null(gpnt, left, rb3_get_black_child(pnt, right), _RB3_BLACK); \
                rb3_connect(pnt, right, gpnt, _RB3_RED); \
                rb3_connect(ggpnt, ggdir, pnt, _RB3_BLACK); \
        } \
} \
 \
_RB3_API _RB3_NEVERINLINE \
void rb3_link_and_rebalance(struct rb3_head *head, struct rb3_head *parent, int dir) \
{ \
        _RB3_ASSERT(dir == RB3_LEFT || dir == RB3_RIGHT); \
        _RB3_ASSERT(!rb3_has_child(parent, dir)); \
 \
        parent->child[dir] = _RB3_CHILD_PTR(head, _RB3_RED); \
        head->parent = _RB3_PARENT_PTR(parent, dir); \
        head->child[RB3_LEFT] = _RB3_CHILD_PTR(_RB3_NULL, _RB3_BLACK); \
        head->child[RB3_RIGHT] = _RB3_CHILD_PTR(_RB3_NULL, _RB3_BLACK); \
        rb3_insert_rebalance(head); \
} \
 \
/* delete implementation */ \
 \
static _RB3_NEVERINLINE \
void rb3_delete_rebalance(struct rb3_head *head) \
{ \
        struct rb3_head *pnt; \
        struct rb3_head *gpnt; \
        struct rb3_head *sibling; \
        struct rb3_head *sleft; \
        struct rb3_head *sleftleft; \
        struct rb3_head *sleftright; \
        int left; \
        int right; \
        int gdir; \
 \
        if (!rb3_get_parent(head)) \
                return; \
 \
        if (!rb3_get_parent(rb3_get_parent(head))) \
                return; \
 \
        pnt = rb3_get_parent(head); \
        left = rb3_get_parent_dir(head); \
        right = !rb3_get_parent_dir(head); \
        gpnt = rb3_get_parent(pnt); \
        gdir = rb3_get_parent_dir(pnt); \
        sibling = rb3_get_child(pnt, right); \
        sleft = rb3_get_child(sibling, left); \
 \
        if (rb3_is_red(pnt, right)) { \
                /* sibling is red */ \
                rb3_connect(pnt, right, sleft, _RB3_BLACK); \
                rb3_connect(sibling, left, pnt, _RB3_RED); \
                rb3_connect(gpnt, gdir, sibling, _RB3_BLACK); \
                rb3_delete_rebalance(head); \
        } else if (rb3_is_red(sibling, right)) { \
                /* outer child of sibling is red */ \
                rb3_connect_null(pnt, right, sleft, rb3_get_color_bit(sibling, left)); \
                rb3_connect(sibling, left, pnt, _RB3_BLACK); \
                rb3_connect(gpnt, gdir, sibling, rb3_get_color_bit(gpnt, gdir)); \
                rb3_set_black(sibling, right); \
        } else if (rb3_is_red(sibling, left)) { \
                /* inner child of sibling is red */ \
                sleftleft = rb3_get_child(sleft, left); \
                sleftright = rb3_get_child(sleft, right); \
                rb3_connect_null(pnt, right, sleftleft, _RB3_BLACK); \
                rb3_connect_null(sibling, left, sleftright, _RB3_BLACK); \
                rb3_connect(sleft, left, pnt, _RB3_BLACK); \
                rb3_connect(sleft, right, sibling, _RB3_BLACK); \
                rb3_connect(gpnt, gdir, sleft, rb3_get_color_bit(gpnt, gdir)); \
        } else if (rb3_is_red(gpnt, gdir)) { \
                /* parent is red */ \
                rb3_set_red(pnt, right); \
                rb3_set_black(gpnt, gdir); \
        } else { \
                /* all relevant nodes are black */ \
                rb3_set_red(pnt, right); \
                rb3_delete_rebalance(pnt); \
        } \
} \
 \
_RB3_API \
void rb3_replace(struct rb3_head *head, struct rb3_head *newhead) \
{ \
        struct rb3_head *left; \
        struct rb3_head *right; \
        struct rb3_head *parent; \
        int pdir; \
        int pcol; \
 \
        *newhead = *head; \
 \
        left = rb3_get_child(head, RB3_LEFT); \
        right = rb3_get_child(head, RB3_RIGHT); \
        parent = rb3_get_parent(head); \
        pdir = rb3_get_parent_dir(head); \
        pcol = rb3_get_color_bit(parent, pdir); \
 \
        if (left) \
                left->parent = _RB3_PARENT_PTR(newhead, RB3_LEFT); \
        if (right) \
                right->parent = _RB3_PARENT_PTR(newhead, RB3_RIGHT); \
        parent->child[pdir] = _RB3_CHILD_PTR(newhead, pcol); \
} \
 \
static _RB3_NEVERINLINE \
void rb3_delete_noninternal(struct rb3_head *head) \
{ \
        struct rb3_head *pnt; \
        struct rb3_head *cld; \
        int pdir; \
        int dir; \
 \
        dir = rb3_get_child(head, RB3_RIGHT) ? RB3_RIGHT : RB3_LEFT; \
 \
        pnt = rb3_get_parent(head); \
        cld = rb3_get_child(head, dir); \
        pdir = rb3_get_parent_dir(head); \
 \
        if (!rb3_is_red(pnt, pdir) && !rb3_is_red(head, dir)) \
                /* To be deleted node is black (and child cannot be repainted) \
                 * => height decreased */ \
                rb3_delete_rebalance(head); \
 \
        rb3_connect_null(pnt, pdir, cld, _RB3_BLACK); \
} \
 \
static _RB3_NEVERINLINE \
void rb3_delete_internal(struct rb3_head *head) \
{ \
        struct rb3_head *subst; \
 \
        subst = rb3_get_next_descendant(head); \
        rb3_delete_noninternal(subst); \
        rb3_replace(head, subst); \
} \
 \
_RB3_API _RB3_NEVERINLINE \
void rb3_unlink_and_rebalance(struct rb3_head *head) \
{ \
        if (rb3_has_child(head, RB3_LEFT) && rb3_has_child(head, RB3_RIGHT)) \
                rb3_delete_internal(head); \
        else \
                rb3_delete_noninternal(head); \
 \
        /* We would really like to write \
            *head = (struct rb3_head) {0}; \
          how it's supposed to be, but compilers spew warnings without end. \
 \
          So we go with the slower and bigger-in-codesize version */ \
        head->child[RB3_LEFT] = 0; \
        head->child[RB3_RIGHT] = 0; \
        head->parent = 0; \
} \
 \
/* node-find implementations using code from inline header functions */ \
 \
_RB3_API _RB3_NEVERINLINE \
struct rb3_head *rb3_find_in_subtree(struct rb3_head *subtree, rb3_cmp cmp, void *data) \
{ \
        return rb3_INLINE_find_in_subtree(subtree, cmp, data); \
} \
 \
_RB3_API _RB3_NEVERINLINE \
struct rb3_head *rb3_find_parent_in_subtree(struct rb3_head *parent, int dir, rb3_cmp cmp, void *data, struct rb3_head **parent_out, int *dir_out) \
{ \
        return rb3_INLINE_find_parent_in_subtree(parent, dir, cmp, data, parent_out, dir_out); \
} \
 \
/* find, insert, delete with rb3_datacmp */ \
 \
_RB3_API _RB3_NEVERINLINE \
struct rb3_head *rb3_insert(struct rb3_tree *tree, struct rb3_head *head, rb3_cmp cmp, void *data) \
{ \
        struct rb3_head *found; \
        struct rb3_head *parent; \
        int dir; \
 \
        parent = rb3_get_base(tree); \
        dir = RB3_LEFT; \
        found = rb3_find_parent_in_subtree(parent, dir, cmp, data, &parent, &dir); \
        if (found) \
                return found; \
        rb3_link_and_rebalance(head, parent, dir); \
        return _RB3_NULL; \
} \
 \
_RB3_API _RB3_NEVERINLINE \
struct rb3_head *rb3_delete(struct rb3_tree *tree, rb3_cmp cmp, void *data) \
{ \
        struct rb3_head *found; \
 \
        found = rb3_find_in_subtree(rb3_get_root(tree), cmp, data); \
        if (found) { \
                rb3_unlink_and_rebalance(found); \
                return found; \
        } \
        return _RB3_NULL; \
} \
 \
_RB3_API _RB3_NEVERINLINE \
struct rb3_head *rb3_find(struct rb3_tree *tree, rb3_cmp cmp, void *data) \
{ \
        return rb3_find_in_subtree(rb3_get_root(tree), cmp, data); \
} \
 \
_RB3_API _RB3_NEVERINLINE \
struct rb3_head *rb3_find_parent(struct rb3_tree *tree, rb3_cmp cmp, void *data, struct rb3_head **parent_out, int *dir_out) \
{ \
        return rb3_find_parent_in_subtree(rb3_get_root(tree), RB3_LEFT, cmp, data, parent_out, dir_out); \
} \
 \
/* */ \
 \
_RB3_API _RB3_NEVERINLINE _RB3_COLD \
void rb3_init(struct rb3_tree *tree) \
{ \
        tree->base.child[RB3_LEFT] = 0; \
        /* ! see doc of rb3_is_base(). */ \
        tree->base.child[RB3_RIGHT] = 3; \
        tree->base.parent = 0; \
} \
 \
_RB3_API _RB3_NEVERINLINE _RB3_COLD \
void rb3_exit(struct rb3_tree *tree) \
{ \
        /* No resources allocated */ \
        (void) tree; \
} \


#define _RB3_GEN_IMPL_HEADER_REAL(_RB3_API)  \
    _RB3_GEN_IMPL_REAL_TYPES(_RB3_API)  \
    _RB3_GEN_IMPL_REAL_INTERNAL(_RB3_API)  \
    _RB3_GEN_IMPL_REAL_NAVIGATE(_RB3_API)  \
    _RB3_GEN_IMPL_REAL_BASIC(_RB3_API)

#define _RB3_GEN_IMPL_REAL(_RB3_API)  \
    _RB3_GEN_IMPL_HEADER_REAL(_RB3_API)  \
    _RB3_GEN_IMPL_REAL_IMPL(_RB3_API)


#define RB3_GEN_TREE_DEFINITION(BASENAME)  \
struct BASENAME {  \
        struct rb3_tree tree;  \
}

/*
 * Access tree through macros, similar to BSD API.
 *
 * Once a wrapped tree is created, say "footree", instead of
 *
 *   footree_insert(the_tree, the_node);
 *
 * we say
 *
 *   RB3_INSERT(footree, the_tree, the_node);
 *
 * and so on.
 */

#define RB3_INIT(BASENAME, tree) \
        BASENAME##_init(tree)

#define RB3_EXIT(BASENAME, tree) \
        BASENAME##_exit(tree)

#define RB3_DELETE_NODE(BASENAME, tree, elm) \
        BASENAME##_unlink_and_rebalance(elm)

#define RB3_MIN(BASENAME, tree) \
        BASENAME##_get_min(tree)

#define RB3_MAX(BASENAME, tree) \
        BASENAME##_get_max(tree)

#define RB3_PREV(BASENAME, elm) \
        BASENAME##_get_prev(elm)

#define RB3_NEXT(BASENAME, elm) \
        BASENAME##_get_next(elm)

#define RB3_INSERT(BASENAME, tree, elm) \
        BASENAME##_insert(tree, elm)

#define RB3_FIND(BASENAME, tree, elm) \
        BASENAME##_find(tree, elm)

#define RB3_DELETE(BASENAME, tree, elm) \
        BASENAME##_delete(tree, elm)


/* iteration macros */

#define RB3_FOREACH_DIR(BASENAME, TREE, NODE, DIR) \
    for (NODE = BASENAME##_get_minmax(TREE, !(DIR)); \
        !!NODE; NODE = BASENAME##_get_prevnext(NODE, (DIR)))

#define RB3_FOREACH_SAFE_DIR(BASENAME, TREE, NODE, NODE1) \
    for (NODE = BASENAME##_get_minmax(TREE, !(DIR)); \
        (!!NODE ? (NODE1 = BASENAME##_get_prevnext(NODE, (DIR)), !!NODE) : !!NODE); \
        NODE = NODE1)

#define RB3_FOREACH(BASENAME, TREE, NODE) \
        RB3_FOREACH_DIR(BASENAME, (TREE), (NODE), RB3_RIGHT)

#define RB3_FOREACH_SAFE(BASENAME, TREE, NODE, NODE1) \
        RB3_FOREACH_DIR_SAFE(BASENAME, (TREE), (NODE), (NODE1), RB3_RIGHT)

#define RB3_FOREACH_REVERSE(BASENAME, TREE, NODE) \
        RB3_FOREACH_DIR(BASENAME, (TREE), (NODE), RB3_LEFT)

#define RB3_FOREACH_REVERSE_SAFE(BASENAME, TREE, NODE, NODE1) \
        RB3_FOREACH_DIR_SAFE(BASENAME, (TREE), (NODE), (NODE1), RB3_LEFT)


#endif  /* RB3_GEN_HEADER */
