.TH rb3ptr 3 "May 25, 2017"
.SH NAME
rb3ptr \- Generic Red-black tree implementation and macros for typesafe access
.SH SYNOPSIS

The rb3ptr API is split into multiple sections.

DATATYPES contains essential structures and definitions.
.LP
BASIC FUNCTIONS has operations on the generic Red-black tree implementation
that provide an ordered container API.
.LP
NAVIGATION FUNCTIONS contains additional functionality for navigation in a
binary search tree.
.LP
MACROS explains the type-specific wrappers for better type-safety and more
convenient access with fixed comparison functions.
.LP
BSD MACROS lists functionality to emulate parts of the BSD
.I <sys/tree.h>
API.


.SS DATATYPES

.BI "struct rb3_tree;"
.LP
.BI "struct rb3_head;"
.LP
.BI "typedef int (*rb3_cmp)(struct rb3_head *" head ", void *" data);


.SS BASIC FUNCTIONS

.BI "void rb3_init(struct rb3_tree *" tree );
.LP
.BI "void rb3_exit(struct rb3_tree *" tree );
.LP
.BI "int rb3_isempty(struct rb3_tree *" tree );
.LP
.BI "struct rb3_head *rb3_get_min(struct rb3_tree *" tree );
.LP
.BI "struct rb3_head *rb3_get_max(struct rb3_tree *" tree );
.LP
.BI "struct rb3_head *rb3_get_prev(struct rb3_head *" head );
.LP
.BI "struct rb3_head *rb3_get_next(struct rb3_head *" head );
.LP
.BI "struct rb3_head *rb3_get_minmax(struct rb3_tree *" tree ", int " dir );
.LP
.BI "struct rb3_head *rb3_get_prevnext(struct rb3_head *" head ", int " dir );
.LP
.BI "struct rb3_head *rb3_find(struct rb3_tree *" tree ", struct rb3_cmp " cmp ", void *" data );
.LP
.BI "struct rb3_head *rb3_find_parent(struct rb3_tree *" tree ", struct rb3_cmp " cmp ", void *" data ", struct rb3_head **" parent_out ", int *" dir_out );
.LP
.BI "void rb3_link_node(struct rb3_head *" head ", struct rb3_head *" parent ", int " dir );
.LP
.BI "void rb3_unlink_node(struct rb3_head *" head );
.LP
.BI "struct rb3_head *rb3_insert(struct rb3_tree *" tree ", struct rb3_head *" head ", struct rb3_cmp " cmp ", void *" data);
.LP
.BI "struct rb3_head *rb3_delete(struct rb3_tree *" tree ", struct rb3_cmp " cmp ", void *" data );


.SS NAVIGATION FUNCTIONS

Note: Valid values for
.I dir
are
.B RB3_LEFT
and
.B RB3_RIGHT
(0 and 1).

.BI "struct rb3_head *rb3_get_root(struct rb3_tree *" tree );
.LP
.BI "struct rb3_head *rb3_get_base(struct rb3_tree *" tree );
.LP
.BI "int rb3_is_base(struct rb3_head *" head );
.LP
.BI "int rb3_get_parent_dir(struct rb3_head *" head );
.LP
.BI "int rb3_has_child(struct rb3_head *" head ", int " dir );
.LP
.BI "struct rb3_head *rb3_get_parent(struct rb3_head *" head );
.LP
.BI "struct rb3_head *rb3_get_child(struct rb3_head *" head ", int " dir );
.LP
.BI "struct rb3_head *rb3_get_prev_ancestor(struct rb3_head *" head );
.LP
.BI "struct rb3_head *rb3_get_next_ancestor(struct rb3_head *" head );
.LP
.BI "struct rb3_head *rb3_get_prev_descendant(struct rb3_head *" head );
.LP
.BI "struct rb3_head *rb3_get_next_descendant(struct rb3_head *" head );
.LP
.BI "struct rb3_head *rb3_get_prevnext_ancestor(struct rb3_head *" head ", int " dir );
.LP
.BI "struct rb3_head *rb3_get_prevnext_descendant(struct rb3_head *" head  ", int " dir );


.SS MACROS

.BI RB3_GEN_IMPL()
.LP
.BI RB3_GEN_IMPL_STATIC()
.LP
.BI RB3_GEN_INLINE( NAME ", " NODETYPE ", " GET_HEAD ", " GET_NODE )
.LP
.BI RB3_GEN_NODECMP( NAME ", " NODETYPE ", " GET_HEAD ", " GET_NODE ", " NODECMP )
.LP
.BI RB3_FOREACH( NAME ", " TREE ", " NODE );
.LP
.BI RB3_FOREACH_REVERSE( NAME ", " TREE ", " NODE );
.LP
.BI RB3_FOREACH_DIR( NAME ", " TREE ", " NODE );
.LP
.BI RB3_FOREACH_SAFE( NAME ", " TREE ", " NODE ", " TMPNODE );
.LP
.BI RB3_FOREACH_REVERSE_SAFE( NAME ", " TREE ", " NODE ", " TMPNODE );
.LP
.BI RB3_FOREACH_DIR_SAFE( NAME ", " TREE ", " NODE ", " TMPNODE );


.SS BSD MACROS

These MACROS expose a BSD
.I <sys/tree.h>
compatible interface. Unfortunately,
.BR RB_LEFT ()
and
.BR RB_RIGHT ()
cannot be supported due to missing information in the signature.

.BI RB_PROTOTYPE()
.LP
.BI RB_PROTOTYPE_STATIC()
.LP
.BI RB_GENERATE()
.LP
.BI RB_GENERATE_STATIC()
.LP
.BI RB_INIT( tree )
.LP
.BI RB_INSERT( NAME ", " tree ", " elm )
.LP
.BI RB_FIND( NAME ", " tree ", " elm )
.LP
.BI RB_REMOVE( NAME ", " tree ", " elm )
.LP
.BI RB_MIN( NAME ", " tree )
.LP
.BI RB_MAX( NAME ", " tree )
.LP
.BI RB_PREV( NAME ", " tree ", " elm )
.LP
.BI RB_NEXT( NAME ", " tree ", " elm )


.SH DOCUMENTATION

This section contains explanations for the structures and prototypes listed
above.

.SS DATATYPES

.B "struct rb3_tree"
is the basic tree type. It holds the root link for one red-black tree in a
running program.

.B "struct rb3_head"
is the linking information for a node in the tree. Data that should be linked
in a tree must contain such a structure. The tree implementation does not care
about the actual data, but simply maintains the links between the link
structures.

.B rb3_cmp
is the function type of user-provided comparisons to direct tree searches. At
each visited node, the function is called with the node and a user-provided
data as arguments. It should return an integer less than, equal to, or greater
than 0, indicating whether the node in the tree compares less than, equal to,
or greater than the user-provided data. This function is always user-provided.
Typically it will make use
.BR offsetof "(3) or the linux"
.BR container_of ()
macro to get at the actual data in which the
.BR "struct rb3_head" node
is embedded.


.SS BASIC FUNCTIONS

.BR rb3_init ()
initializes a
.B struct rb3_tree.
Zeroing out the structure (e.g., with
.BR memset()
or static initialization) is also believed to work.

.BR rb3_exit ()
frees the resources associated with a tree. There are currently no such
resources, and it should also be ok to zero it out. Usage of this function is
recommended for future-proofness and also for reasons of symmetry.

.BR rb3_isempty ()
tests if a tree does not contain any nodes. This of course is true after
initialization.

.BR rb3_get_min "() and " rb3_get_max ()
return the leftmost / rightmost element linked in a tree. If the tree is empty,
NULL is returned.

.BR rb3_get_prev "() and " rb3_get_next ()
return the previous / next node linked in the same tree (with respect to
in-order traversal). If no such node exists, NULL is returned.

.BR rb3_get_minmax "() and " rb3_get_prevnext ()
can be used instead of
.BR rb3_get_min "(), " rb3_get_max "(), " rb3_get_prev "(), and " rb3_next () .
They take the direction as runtime parameter
.RB ( RB3_LEFT " or " RB3_RIGHT ).


.BR rb3_find ()
finds a node in a tree. If no node comparing equal (i.e., the comparison
function returns 0 given the visited node and the user-provided data) is found
in the tree, NULL is returned.

.BR rb3_find_parent ()
is similar to
.BR rb3_find (),
but when the search is unsuccessful, the appropriate insertion point for a node
matching the search is returned in the out-arguments.
.BR rb3_link_node ()
can then be used to add the node.
.RB ( rb3_insert ()
combines these two operations in a single function call).

.BR rb3_link_node ()
can be used to link a given node into a tree given an insertion point (parent
node and its child direction). The appropriate insertion point can be found
using
.BR rb3_find_parent ().

.BR rb3_unlink_node ()
can be used to unlink a given node from a tree without any search. The node
must be known to be linked in a tree.

.BR rb3_insert ()
can be used to insert a new node into a tree at a suitable insertion point. It
takes a tree, the new node to insert, and a
.B rb3_cmp
function implementing the node ordering to direct the search. If a node
comparing equal (i.e., the comparison function returns 0 given the visited node
and the user-provided node) is found in the tree, that node is returned.
Otherwise, the to-be-inserted node is linked into the tree and NULL is
returned.

.BR rb3_delete ()
does a node search in a tree given a comparison function and data. If a
matching node is found, it is unlinked from the tree and a pointer to it is
returned. Otherwise, NULL is returned.


.SS NAVIGATION FUNCTIONS

.BR rb3_get_root ()
returns the root node in the tree, or NULL if the tree is empty.

.BR rb3_get_base ()
returns the base head of the tree, which always exists. If the tree is
nonempty, the root node is linked as left child of the base node. This is an
implementation detail and need not be relied upon in most situations.

.BR rb3_get_parent_dir ()
returns RB3_LEFT or RB3_RIGHT depending on whether the given link node is the
left or right child of its parent. This is a single bitwise operation on the
link structure, so is more efficient than testing both childs of the parent's
link structure.

.BR rb3_has_child ()
tests whether the given link has a child in the given direction.

.BR rb3_get_parent ()
returns the parent link structure of the given node. If the given node is the
root node, the base head is returned. If this is not what you want, test if the
return value has itself a parent. (The base head is the only head that has no
parent).

.BR rb3_get_child ()
returns the left or right child of the given node, depending on the given
direction value
.RB ( RB3_LEFT " or " RB3_RIGHT )

.BR rb3_get_prev_ancestor ()
returns the nearest left ancestor of the given head link structure. If none
exists, NULL is returned.

.BR rb3_get_next_ancestor ()
returns the nearest right ancestor of the given head link structure. If none
exists, NULL is returned.

.BR rb3_get_prev_descendant ()
returns the nearest left descendant of the given head link structure. If none
exists, NULL is returned.

.BR rb3_get_next_descendant ()
returns the nearest right descendant of the given head link structure. If none
exists, NULL is returned.

.BR rb3_get_prevnext_ancestor ()
returns the nearest left or right ancestor (depending on the given direction)
of the given head link structure. If none exists, NULL is returned.

.BR rb3_get_prevnext_descendant ()
returns the nearest left or right descendant (depending on the given direction)
of the given head link structure. If none exists, NULL is returned.


.SS MACROS

.BR RB3_GEN_IMPL ()
evaluates to a complete implementation of the rb3ptr API with
.I extern
linkage. Use this only if you can't use a separately compiled rb3ptr libray.
Macros are hard to debug.

.BR RB3_GEN_IMPL_STATIC ()
evaluates to a complete implementation of the rb3ptr API with
.I static
linkage. Use this only if no other file in the same projects need rb3ptr's
functionality.

.BR RB3_GEN_INLINE ()
evaluates to an implementation of the non-comparison-related functionality of
rb3ptr wrapped for a specific datatype.
.I NAME
should be a prefix for these functions, such as for example
.IR footree .
.I NODETYPE
should be the node type managed by this set of generated functions, such as
for example
.IR struct foo
(see the example below).
.I GET_HEAD " and " GET_NODE
should be macros or functions for the generated implementation's use to
retrieve the embedded link structure from a node, or vice versa.

.BR RB3_GEN_NODECMP ()
TODO

.BR RB3_FOREACH ()
is a for-loop iteration macro.
.I NAME
should be the prefix used in
.IR RB3_GEN_INLINE ().
.I TREE
should be a tree of the generated type
.RB ( "struct NAME" ).
.I NODE
should by a value of type
.IR "NODETYPE *" .
It is used as iteration variable.


.BR RB3_FOREACH_REVERSE ()
.BR RB3_FOREACH_DIR ()
.BR RB3_FOREACH_SAFE ()
.BR RB3_FOREACH_REVERSE_SAFE ()
.BR RB3_FOREACH_DIR_SAFE ()
TODO


.SS BSD MACROS

For documentation of the BSD macros please refer to
.BR tree (3)


.SH EXAMPLE

.nf
#include <rb3ptr.h>

/*
 * Include the generic implementation. Alternatively, you can link with a
 * seperately compiled generic implementation
 */
RB3_GEN_IMPL_STATIC();

/*
 * Define a node datatype and a compare operation
 */
struct foo {
	/* the node type must include a struct rb3_head. */
	struct rb3_head head;
	int val;
}

int compare(struct foo *a, struct foo *b)
{
	return (a\->val > b\->val) \- (a\->val < b\->val);
}

RB3_GEN_INLINE_PROTO_STATIC(footree, struct foo, head);
RB3_GEN_NODECMP_PROTO_STATIC(footree, struct foo, head, compare);

void testoperations(void)
{
	struct footree tree;
	struct foo *iter;
	struct foo foo[42];
	size_t i;

	footree_init(&tree);
	for (i = 0; i < 42; i++)
		foo[i].val = rand();
	for (i = 0; i < 42; i++)
		footree_insert(&tree, &foo[i]);
	for (iter = footree_get_min(&tree); iter != NULL; iter = footree_get_next(iter))
		printf("iter %d\\n", iter\->val);
	for (i = 0; i < 42; i++)
		footree_delete(&tree, &foo[i]);
	footree_exit(&tree);
}
.fi
